//======================================================================================
//======================================================================================
// Filename: PSP103_module.include
//======================================================================================
//======================================================================================
//
//  (c) Copyright notice
//
//  Since 2015 until today, PSP has been co-developed by NXP Semiconductors and
//  CEA-Leti. For this part of the model, each claim undivided ownership and copyrights
//  Since 2012 until 2015, PSP has been co-developed by NXP Semiconductors and
//  Delft University of Technology. For this part of the model, each claim undivided
//  ownership and copyrights
//  Until and including 2011, PSP has been co-developed by NXP Semiconductors and
//  Arizona State University. For this part of the model, NXP Semiconductors claims
//  undivided ownership and copyrights.
//
//
//  Version: 103.8.0 (PSP), 200.6.1 (JUNCAP), July 2020
//
//======================================================================================
//======================================================================================
//
// Further information can be found in the file releasenotesPSP103.txt
//

//  --------------------------------------------------------------------------------------------------------------
//  Node definitions
//  --------------------------------------------------------------------------------------------------------------

`ifdef SelfHeating
    inout      D, G, S, B, DT;
`else // SelfHeating
    inout      D, G, S, B;
`endif // SelfHeating
electrical D;
electrical G;
electrical S;
electrical B;
`ifdef SelfHeating
    thermal DT;
    branch     (DT) br_rth, br_ith;
`endif // SelfHeating

//  Internal nodes and branches for correlated drain and gate noise
electrical NOI;
branch (NOI) NOII;
branch (NOI) NOIR;
branch (NOI) NOIC;

//  Internal nodes for gate and bulk resistors
electrical GP;
electrical SI;
electrical DI;
electrical BP;
electrical BI;
electrical BS;
electrical BD;

//  Internal nodes and branches for spline collocation (NQS)
`ifdef NQSmodel
    electrical INT1;
    electrical INT2;
    electrical INT3;
    electrical INT4;
    electrical INT5;
    electrical INT6;
    electrical INT7;
    electrical INT8;
    electrical INT9;
    branch(INT1) SPLINE1;
    branch(INT2) SPLINE2;
    branch(INT3) SPLINE3;
    branch(INT4) SPLINE4;
    branch(INT5) SPLINE5;
    branch(INT6) SPLINE6;
    branch(INT7) SPLINE7;
    branch(INT8) SPLINE8;
    branch(INT9) SPLINE9;
    branch(INT1) RES1;
    branch(INT2) RES2;
    branch(INT3) RES3;
    branch(INT4) RES4;
    branch(INT5) RES5;
    branch(INT6) RES6;
    branch(INT7) RES7;
    branch(INT8) RES8;
    branch(INT9) RES9;
`endif // NQSmodel



//  --------------------------------------------------------------------------------------------------------------
//  Instance parameters
//  --------------------------------------------------------------------------------------------------------------

//  Instance parameters for global and binning models only
`IPRco(L              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design length")
`IPRco(W              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design width")
`IPRnb(SA             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from one side")
`IPRnb(SB             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from other side")
`IPRnb(SD             ,0.0        ,"m"                                  ,"Distance between neighbouring fingers")
`IPRcz(SCA            ,0.0        ,""                                   ,"Integral of the first distribution function for scattered well dopants")
`IPRcz(SCB            ,0.0        ,""                                   ,"Integral of the second distribution function for scattered well dopants")
`IPRcz(SCC            ,0.0        ,""                                   ,"Integral of the third distribution function for scattered well dopants")
`IPRnb(SC             ,0.0        ,"m"                                  ,"Distance between OD-edge and nearest well edge")
`IPRco(NF             ,1.0        ,""         ,1.0         ,inf         ,"Number of fingers")
`IPRcc(NGCON          ,1.0        ,""         ,1.0         ,2.0         ,"Number of gate contacts")
`IPRnb(XGW            ,1.0e-7     ,"m"                                  ,"Distance from the gate contact to the channel edge")
`IPRnb(NRS            ,0.0        ,""                                   ,"Number of squares of source diffusion")
`IPRnb(NRD            ,0.0        ,""                                   ,"Number of squares of drain diffusion")

//  Instance parameters for local model only
`IPRco(JW             ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source/drain junction")

//  Instance parameters for global, binning, and local models
`IPRnb(DELVTO         ,0.0        ,"V"                                  ,"Threshold voltage shift parameter")
`IPRcz(FACTUO         ,1.0        ,""                                   ,"Zero-field mobility pre-factor")
`IPRnb(DELVTOEDGE     ,0.0        ,"V"                                  ,"Threshold voltage shift parameter of edge transistor")
`IPRcz(FACTUOEDGE     ,1.0        ,""                                   ,"Zero-field mobility pre-factor of edge transistor")
`IPRco(ABSOURCE       ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(LSSOURCE       ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of source junction")
`IPRco(LGSOURCE       ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source junction")
`IPRco(ABDRAIN        ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(LSDRAIN        ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of drain junction")
`IPRco(LGDRAIN        ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of drain junction")
`IPRco(AS             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(PS             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of source junction")
`IPRco(AD             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(PD             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of drain junction")
`IPRco(MULT           ,1.0        ,""         ,0.0         ,inf         ,"Number of devices in parallel")

//  --------------------------------------------------------------------------------------------------------------
//  PSP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "PSP103_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  JUNCAP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "JUNCAP200_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  Variables
//  --------------------------------------------------------------------------------------------------------------

//  Variables for switch (initial_model parts)
integer CHNL_TYPE;

//  Instance local variables
real NF_i, invNF, L_i, W_i, SA_i, SB_i, SD_i, SC_i, XGW_i, JW_i, SCA_i, SCB_i, SCC_i, NGCON_i, MULT_i, FACTUO_i, DELVTO_i;
real FACTUOEDGE_i, DELVTOEDGE_i;

//  Instance local variables for juncap
real ABS_i, LSS_i, LGS_i, ABD_i, LSD_i, LGD_i, jwcorr, jww;

//  Variables of internal global-binning parameters of charge model
real CFACL_i, CFACW_i, CFACLEXP_i, THESATACO_i, THESATACL_i, THESATACLEXP_i, THESATACW_i, THESATACLW_i, AXACO_i, AXACL_i, ALPACL_i;
real ALPACLEXP_i, ALPACW_i, POCFAC_i, PLCFAC_i, PWCFAC_i, PLWCFAC_i, POTHESATAC_i, PLTHESATAC_i, PWTHESATAC_i, PLWTHESATAC_i;
real POAXAC_i, PLAXAC_i, PWAXAC_i, PLWAXAC_i, POALPAC_i, PLALPAC_i, PWALPAC_i, PLWALPAC_i, KVSATAC_i;

//  Variables of local model parameters
real VFB_p, STVFB_p, ST2VFB_p, TOX_p, EPSROX_p, NEFF_p, FACNEFFAC_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, VNSUB_p, NSLP_p, DNSUB_p;
real DPHIB_p, DELVTAC_p, NP_p, CT_p, CTG_p, CTB_p, STCT_p, TOXOV_p, TOXOVD_p, NOV_p, NOVD_p, PSCE_p, PSCED_p, PSCEB_p, CF_p, CFAC_p;
real CFD_p, CFB_p, BETN_p, STBET_p, MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, THECS_p, STTHECS_p, XCOR_p, STXCOR_p;
real FETA_p, RS_p, STRS_p, RSB_p, RSG_p, THESAT_p, THESATAC_p, STTHESAT_p, THESATB_p, THESATG_p, AX_p, AXAC_p, ALP_p, ALPAC_p;
real ALP1_p, ALP2_p, VP_p, A1_p, A2_p, STA2_p, A3_p, A4_p, GCO_p, IGINV_p, IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, GC2OV_p, GC3OV_p;
real CHIB_p, AGIDL_p, AGIDLD_p, BGIDL_p, BGIDLD_p, STBGIDL_p, STBGIDLD_p, CGIDL_p, CGIDLD_p, COX_p, CGOV_p, CGOVD_p, FCGOVACC_p;
real FCGOVACCD_p, CGOVACCG_p, CGBOV_p, CINR_p, CINRD_p, DVFBINR_p, FCINRDEP_p, FCINRACC_p, AXINR_p, CFR_p, CFRD_p, FNT_p, FNTEXC_p;
real NFA_p, NFB_p, NFC_p, EF_p, VFBEDGE_p, STVFBEDGE_p, DPHIBEDGE_p, NEFFEDGE_p, CTEDGE_p, BETNEDGE_p, STBETEDGE_p, PSCEEDGE_p;
real PSCEBEDGE_p, PSCEDEDGE_p, CFEDGE_p, CFDEDGE_p, CFBEDGE_p, FNTEDGE_p, NFAEDGE_p, NFBEDGE_p, NFCEDGE_p, EFEDGE_p, RG_p, RSH_i;
real RSHD_i, RSE_p, RDE_p, RWELL_p, RBULK_p, RJUNS_p, RJUND_p;
`ifdef SelfHeating
    real RTH_p, CTH_p, STRTH_p;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_p;
`endif // NQSmodel

//  Variables of clipped local model parameters
real VFB_i, STVFB_i, ST2VFB_i, STCT_i, TOX_i, EPSROX_i, NEFF_i, FACNEFFAC_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, VNSUB_i, NSLP_i;
real DNSUB_i, DPHIB_i, DELVTAC_i, NP_i, CT_i, CTG_i, CTB_i, TOXOV_i, TOXOVD_i, NOV_i, NOVD_i, CF_i, CFAC_i, CFD_i, CFB_i, PSCE_i, PSCEB_i;
real PSCED_i, BETN_i, STBET_i, MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, THECS_i, STTHECS_i, XCOR_i, STXCOR_i, FETA_i, RS_i, STRS_i;
real RSB_i, RSG_i, THESAT_i, THESATAC_i, STTHESAT_i, THESATB_i, THESATG_i, AX_i, AXAC_i, ALP_i, ALPAC_i, ALP1_i, ALP2_i, VP_i, A1_i, A2_i;
real STA2_i, A3_i, A4_i, GCO_i, IGINV_i, IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, GC2OV_i, GC3OV_i, CHIB_i, AGIDL_i, AGIDLD_i, BGIDL_i;
real BGIDLD_i, STBGIDL_i, STBGIDLD_i, CGIDL_i, CGIDLD_i, COX_i, CGOV_i, CGOVD_i, FCGOVACC_i, FCGOVACCD_i, CGOVACCG_i, CGBOV_i, CINR_i;
real CINRD_i, DVFBINR_i, FCINRDEP_i, FCINRACC_i, AXINR_i, CFR_i, CFRD_i, FNT_i, FNTEXC_i, NFA_i, NFB_i, NFC_i, EF_i, VFBEDGE_i, STVFBEDGE_i;
real DPHIBEDGE_i, NEFFEDGE_i, CTEDGE_i, BETNEDGE_i, STBETEDGE_i, PSCEEDGE_i, PSCEBEDGE_i, PSCEDEDGE_i, CFEDGE_i, CFDEDGE_i, CFBEDGE_i;
real FNTEDGE_i, NFAEDGE_i, NFBEDGE_i, NFCEDGE_i, EFEDGE_i, RG_i, RSE_i, RDE_i, RBULK_i, RJUNS_i, RJUND_i, RWELL_i;
`ifdef SelfHeating
    real RTH_i, CTH_i, STRTH_i;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_i;
`endif // NQSmodel

//  Variables for scaling rules
real iL, iW, delLPS, delWOD, LE, WE, LEcv, WEcv, Lcv, Wcv, iLE, iWE, L_f, L_slif, W_f, XGWE, NSUB0e, NPCKe, LPCKe, AA, BB, NSUB;
real FBET1e, LP1e, GPE, GWE, tmpx, Lnoi, Lred, WE_edge, iWE_edge, GPE_edge, KVTHOWE, KUOWE;
`ifdef SelfHeating
    real deltaRth;
`endif // SelfHeating

//  Variables for binning-rules
real iLEWE, iiLE, iiWE, iiLEWE, iiiLEWE, iLEcv, iiLEcv, iiWEcv, iiLEWEcv, iiiLEWEcv, iLcv, iiLcv, iiWcv, iiLWcv, iiiLWcv;

//  Variables for general temperature scaling
real TKR, TKA, rTa, delTa, phita, inv_phita, TKD, TKD_sq, delT, rTn, ln_rTn, inv_phit, Eg, phibFac;

//  JUNCAP2 variables
`include "JUNCAP200_varlist.include"

//  Local parameters after temperature scaling and variables used in self heating effect
real VFB_T, CT_T, CTG_T, BETN_T, MUE_T, THEMU_T, CS_T, THECS_T, XCOR_T, RS_T, BGIDL_T, BGIDLD_T, A2_T, VFBEDGE_T, BETNEDGE_T;
`ifdef SelfHeating
    real RTH_T;
`else // SelfHeating
    // in the self heating model, these variables are declared locally in the evaluate block
    real phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
    real ntedge;
`endif // SelfHeating

//  Variables for channel temperature scaling (including self heating effect)
real phib_dc, G_0_dc, kp, np, arg2max, qlim2, qb0, dphibq, sqrt_phib_dc, phix_dc, aphi_dc, bphi_dc, phix2, phix1_dc, alpha_b;
real us1, us21, phib_ac, G_0_ac, phix_ac, aphi_ac, bphi_ac, phix1_ac, tf_ct, tf_bet, tf_mue, tf_cs, tf_xcor, tf_ther, THER_i, tf_thesat;
real tf_betedge, phibedge, Gfedge, phixedge, aphiedge, bphiedge, phix2edge, phix1edge;

//  Variables used in instance initializing
real EPSSI, EPSOX, CoxPrime, tox_sq, Cox_over_q, NEFFAC_i, qq, E_eff0, eta_mu, eta_mu1, inv_AX, inv_VP, CoxovPrime, CoxovPrime_d, GOV_s;
real GOV_d, GOV2_s, GOV2_d, dxgb_ov_th, dxgb_ov_s, dxgb_ov_d, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d;
real inv_CHIB, B_fact, BCH, BOV, BOV_d, GCQ, GCQOV, tf_ig, AGIDLs, AGIDLDs, BGIDLs, BGIDLDs, Vinr_max, ainr, fac_exc, ggate, gsource;
real gdrain, gbulk, gjuns, gjund, gwell;

//  Variables for bias affectation
real Vgs, Vds, Vsb, Vdb, Vgb, Vjun_s, Vjun_d, VgsPrime, VsbPrime, VdbPrime, VgdPrime;
real Vdsx;

//  Global variables used in PSP103_SPCalculation.include
real Vgb1, Vdsp, delVg, Vdsat_lim, Vdsat;

//  Global variables used in current and charge calculations
real xgs_ov, xgd_ov, xgb_ov, Vsbstar_dc, Vsbstar_dc_tmp, Vmb, us, usnew, Vmbnew, qeff1_dc, Voxm_dc, GdL_dc, eta_p_dc, Gvsat_dc;
real Gmob_dL_dc, x_ds_dc, x_m_dc, Gf_dc, Vdsat_dc, Udse_dc, SP_OV_xg, xs_ov, xd_ov, Vovs, Vovd, zg, TP, Fs1, Fs2, Fs3, Fs, Vm, Dch;
real arg2mina, psi_t, arg1, Dsi, Dgate, Igc0, igc, igcd_h, u0, x, u0_div_H, Bg, Ag, xsq, inv_x, ex, inv_ex, Sg, Igc, Igb, Vtovd, Igidl;
real Vtovs, Igisl, delVsat, Vsbstar_ac, xg_ac, Gf_ac, Vgb1_ac, qeff1_ac, Voxm_ac, alpha_ac, dps_ac, qim_ac, GdL_ac, H_ac, QG, QI, QD;
real QB, Fj, Fj2, QCLM, Qg, Qd, Qb, Qs, Qsinr, Qdinr, Qginr, Qg_ov_s, Qg_ov_d, Qg_ov, Qgs_ov, Qgd_ov, Qgb_ov, Qfgs, Qfgd, rgatenoise;
real rsourcenoise, rdrainnoise, rbulknoise, rwellnoise, rjundnoise, rjunsnoise;

//  Global variables used in macros
real tme1, tme2;
real inv_GOV, SP_OV_eps, SP_OV_delta, mutau, nu;
real Q_EDGE_xsth, Q_EDGE_xth0, Q_EDGE_xth, Q_EDGE_n, Q_EDGE_n_inv, Q_EDGE_xgt, Q_EDGE_xgt0, Q_EDGE_xgt0e, Q_EDGE_qi0si, Q_EDGE_qi0;
real Q_EDGE_exp_x, Q_EDGE_d0, Q_EDGE_d0p, Q_EDGE_sqerr, Q_EDGE_errq;

//  Global variables used in noise section
real N1, Nm1, Delta_N1, Sfl, t1, sqt2, t2, r, lc, lcinv2, g_ideal, mid, temp2_exc, wsat_exc, temp_exc, thesat1_exc, zsat_exc, Gvsat_exc;
real gfac, Sidexc, sqid, mig, migid0, migid, CGeff, sqig, c_igid, shot_igcsx, shot_igcdx, shot_igsov, shot_igdov, shot_iavl, jnoisex_s, jnoisex_d;
real shot_igs, shot_igd, anoisedge, N1edge, Nm1edge, Delta_N1edge, H0edge, t1edge, sqt2edge, t2edge, redge, lcedge, lcinv2edge;
real g_idealedge;

//  Variables used in NQS-calculations
`ifdef NQSmodel
    integer SWNQS_i;
    real xgm_dc, thesat1_dc, xgm_ac, x_m_ac, thesat1_ac, margin_dc, margin_ac;
    real Qp1_0, Qp2_0, Qp3_0, Qp4_0, Qp5_0, Qp6_0, Qp7_0, Qp8_0, Qp9_0, fk1, fk2, fk3, fk4, fk5, fk6, fk7, fk8, fk9, phi_p1, phi_p2, phi_p3;
    real phi_p4, phi_p5, phi_p6, phi_p7, phi_p8, phi_p9, Qp1, Qp2, Qp3, Qp4, Qp5, Qp6, Qp7, Qp8, Qp9, Qp0, QpN, QG_NQS, QS_NQS, QD_NQS, pd;
    real Gp, Gp2, a_factrp, marginp, x_sp, x_dp, zsat_nqs, dfQi, fQi, dQis, dQis_1, d2Qis, dQbs, dQy, d2Qy, dpsy2, ym, Tnorm, Qb_tmp;
    real QbSIGN, r_nqs, vnorm, vnorm_inv, NQS_xg1, NQS_yg, NQS_z, NQS_eta, NQS_a, NQS_c, NQS_tau, NQS_D0, NQS_xi, NQS_p, NQS_q, NQS_temp;
    real NQS_A_fac, NQS_xbar, NQS_w, NQS_x0, NQS_u, NQS_y0, xphi, fk0, thesat2, Fvsat, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
`endif // NQSmodel

//  Gmin variable
real gmin;

//  --------------------------------------------------------------------------------------------------------------
//  Variables for operating point info
//  --------------------------------------------------------------------------------------------------------------
real id_op, is, ig, ib, P_D, facvsb, facvsb0, sig1k, vth_i, vts_i, ids_i;
`OPP(ctype             ,""             ,"Flag for channel type")
`OPP(sdint             ,""             ,"Flag for source-drain interchange")
`OPP(ise               ,"A"            ,"Total source current")
`OPP(ige               ,"A"            ,"Total gate current")
`OPP(ide               ,"A"            ,"Total drain current")
`OPP(ibe               ,"A"            ,"Total bulk current")
`OPP(ids               ,"A"            ,"Drain current, excl. edge transistor currents, avalanche, tunnel, GISL, GIDL, and junction currents")
`OPP(idb               ,"A"            ,"Drain to bulk current")
`OPP(isb               ,"A"            ,"Source to bulk current")
`OPP(igs               ,"A"            ,"Gate-source tunneling current")
`OPP(igd               ,"A"            ,"Gate-drain tunneling current")
`OPP(igb               ,"A"            ,"Gate-bulk tunneling current")
`OPP(idedge            ,"A"            ,"Drain current of edge transistors")
`OPP(igcs              ,"A"            ,"Gate-channel tunneling current (source component)")
`OPP(igcd              ,"A"            ,"Gate-channel tunneling current (drain component)")
`OPP(iavl              ,"A"            ,"Substrate current due to weak avelanche")
`OPP(igisl             ,"A"            ,"Gate-induced source leakage current")
`OPP(igidl             ,"A"            ,"Gate-induced drain leakage current")
`OPP(ijs               ,"A"            ,"Total source junction current")
`OPP(ijsbot            ,"A"            ,"Source junction current (bottom component)")
`OPP(ijsgat            ,"A"            ,"Source junction current (gate-edge component)")
`OPP(ijssti            ,"A"            ,"Source junction current (STI-edge component)")
`OPP(ijd               ,"A"            ,"Total drain junction current")
`OPP(ijdbot            ,"A"            ,"Drain junction current (bottom component)")
`OPP(ijdgat            ,"A"            ,"Drain junction current (gate-edge component)")
`OPP(ijdsti            ,"A"            ,"Drain junction current (STI-edge component)")
`OPP(vds               ,"V"            ,"Drain-source voltage")
`OPP(vgs               ,"V"            ,"Gate-source voltage")
`OPP(vsb               ,"V"            ,"Source-bulk voltage")
`OPP(vto               ,"V"            ,"Zero-bias threshold voltage")
`OPP(vts               ,"V"            ,"Threshold voltage including back bias effects")
`OPP(vth               ,"V"            ,"Threshold voltage including back bias and drain bias effects")
`OPP(vgt               ,"V"            ,"Effective gate drive voltage including back bias and drain bias effects")
`OPP(vdss              ,"V"            ,"Drain saturation voltage at actual bias")
`OPP(vsat              ,""             ,"Saturation limit")
`ifdef OPderiv
    `OPP(gm                ,"1/Ohm"        ,"Transconductance")
    `OPP(gmb               ,"1/Ohm"        ,"Substrate transconductance")
    `OPP(gds               ,"1/Ohm"        ,"Output conductance")
    `OPP(gjs               ,"1/Ohm"        ,"Source junction conductance")
    `OPP(gjd               ,"1/Ohm"        ,"Drain junction conductance")
    `OPP(cdd               ,"F"            ,"Drain capacitance")
    `OPP(cdg               ,"F"            ,"Drain-gate capacitance")
    `OPP(cds               ,"F"            ,"Drain-source capacitance")
    `OPP(cdb               ,"F"            ,"Drain-bulk capacitance")
    `OPP(cgd               ,"F"            ,"Gate-drain capacitance")
    `OPP(cgg               ,"F"            ,"Gate capacitance")
    `OPP(cgs               ,"F"            ,"Gate-source capacitance")
    `OPP(cgb               ,"F"            ,"Gate-bulk capacitance")
    `OPP(csd               ,"F"            ,"Source-drain capacitance")
    `OPP(csg               ,"F"            ,"Source-gate capacitance")
    `OPP(css               ,"F"            ,"Source capacitance")
    `OPP(csb               ,"F"            ,"Source-bulk capacitance")
    `OPP(cbd               ,"F"            ,"Bulk-drain capacitance")
    `OPP(cbg               ,"F"            ,"Bulk-gate capacitance")
    `OPP(cbs               ,"F"            ,"Bulk-source capacitance")
    `OPP(cbb               ,"F"            ,"Bulk capacitance")
    `OPP(cgsol             ,"F"            ,"Total gate-source overlap capacitance")
    `OPP(cgdol             ,"F"            ,"Total gate-drain overlap capacitance")
    `OPP(cjs               ,"F"            ,"Total source junction capacitance")
    `OPP(cjsbot            ,"F"            ,"Source junction capacitance (bottom component)")
    `OPP(cjsgat            ,"F"            ,"Source junction capacitance (gate-edge component)")
    `OPP(cjssti            ,"F"            ,"Source junction capacitance (STI-edge component)")
    `OPP(cjd               ,"F"            ,"Total drain junction capacitance")
    `OPP(cjdbot            ,"F"            ,"Drain junction capacitance (bottom component)")
    `OPP(cjdgat            ,"F"            ,"Drain junction capacitance (gate-edge component)")
    `OPP(cjdsti            ,"F"            ,"Drain junction capacitance (STI-edge component)")
`endif // OPderiv
`OPP(weff              ,"m"            ,"Effective channel width for geometrical models")
`OPP(leff              ,"m"            ,"Effective channel length for geometrical models")
`ifdef OPderiv
    `OPP(u                 ,""             ,"Transistor gain")
    `OPP(rout              ,"Ohm"          ,"Small-signal output resistance")
    `OPP(vearly            ,"V"            ,"Equivalent Early voltage")
    `OPP(beff              ,"A/V^2"        ,"Gain factor")
    `OPP(fug               ,"Hz"           ,"Unity gain frequency at actual bias")
    `OPP(rg                ,"Ohm"          ,"Gate resistance")
    `OPP(sfl               ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz")
    `OPP(sqrtsff           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density at 1 kHz")
    `OPP(sqrtsfw           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density")
    `OPP(sid               ,"A^2/Hz"       ,"White noise current spectral density")
    `OPP(sig               ,"A^2/Hz"       ,"Induced gate noise current spectral density at 1 Hz")
    `OPP(cigid             ,""             ,"Imaginary part of correlation coefficient between Sig and Sid")
    `OPP(fknee             ,"Hz"           ,"Cross-over frequency above which white noise is dominant")
    `OPP(sigs              ,"A^2/Hz"       ,"Gate-source current noise spectral density")
    `OPP(sigd              ,"A^2/Hz"       ,"Gate-drain current noise spectral density")
    `OPP(siavl             ,"A^2/Hz"       ,"Impact ionization current noise spectral density")
    `OPP(ssi               ,"A^2/Hz"       ,"Total source junction current noise spectral density")
    `OPP(sdi               ,"A^2/Hz"       ,"Total drain junction current noise spectral density")
    `OPP(sfledge           ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz of edge transistors")
    `OPP(sidedge           ,"A^2/Hz"       ,"White noise current spectral density of edge transistors")
`endif // OPderiv
// local parameters after scaling, T-scaling, and clipping
`OPP(lp_vfb            ,"V"            ,"Local parameter VFB after T-scaling and clipping")
`OPP(lp_stvfb          ,"V/K"          ,"Local parameter STVFB after clipping")
`OPP(lp_st2vfb         ,"K^-1"         ,"Local parameter ST2VFB after clipping")
`OPP(lp_tox            ,"m"            ,"Local parameter TOX after clipping")
`OPP(lp_epsrox         ,""             ,"Local parameter EPSROX after clipping")
`OPP(lp_neff           ,"m^-3"         ,"Local parameter NEFF after clipping")
`OPP(lp_facneffac      ,""             ,"Local parameter FACNEFFAC after clipping")
`OPP(lp_gfacnud        ,""             ,"Local parameter GFACNUD after clipping")
`OPP(lp_vsbnud         ,"V"            ,"Local parameter VSBNUD after clipping")
`OPP(lp_dvsbnud        ,"V"            ,"Local parameter DVSBNUD after clipping")
`OPP(lp_vnsub          ,"V"            ,"Local parameter VNSUB after clipping")
`OPP(lp_nslp           ,"V"            ,"Local parameter NSLP after clipping")
`OPP(lp_dnsub          ,"V^-1"         ,"Local parameter DNSUB after clipping")
`OPP(lp_dphib          ,"V"            ,"Local parameter DPHIB after clipping")
`OPP(lp_delvtac        ,"V"            ,"Local parameter DELVTAC after clipping")
`OPP(lp_np             ,"m^-3"         ,"Local parameter NP after clipping")
`OPP(lp_toxov          ,"m"            ,"Local parameter TOXOV after clipping")
`OPP(lp_toxovd         ,"m"            ,"Local parameter TOXOVD after clipping")
`OPP(lp_nov            ,"m^-3"         ,"Local parameter NOV after clipping")
`OPP(lp_novd           ,"m^-3"         ,"Local parameter NOVD after clipping")
`OPP(lp_ct             ,""             ,"Local parameter CT after clipping")
`OPP(lp_ctg            ,""             ,"Local parameter CTG after clipping")
`OPP(lp_ctb            ,""             ,"Local parameter CTB after clipping")
`OPP(lp_stct           ,""             ,"Local parameter STCT after clipping")
`OPP(lp_cf             ,""             ,"Local parameter CF after clipping")
`OPP(lp_cfac           ,""             ,"Local parameter CFAC after clipping")
`OPP(lp_cfd            ,"V^-1"         ,"Local parameter CFD after clipping")
`OPP(lp_cfb            ,"V^-1"         ,"Local parameter CFB after clipping")
`OPP(lp_psce           ,""             ,"Local parameter PSCE after clipping")
`OPP(lp_psceb          ,"V^-1"         ,"Local parameter PSCEB after clipping")
`OPP(lp_psced          ,"V^-1"         ,"Local parameter PSCED after clipping")
`OPP(lp_betn           ,"m^2/(V s)"    ,"Local parameter BETN after T-scaling and clipping")
`OPP(lp_stbet          ,""             ,"Local parameter STBET after clipping")
`OPP(lp_mue            ,"m/V"          ,"Local parameter MUE after T-scaling and clipping")
`OPP(lp_stmue          ,""             ,"Local parameter STMUE after clipping")
`OPP(lp_themu          ,""             ,"Local parameter THEMU after T-scaling and clipping")
`OPP(lp_stthemu        ,""             ,"Local parameter STTHEMU after clipping")
`OPP(lp_cs             ,""             ,"Local parameter CS after T-scaling and clipping")
`OPP(lp_stcs           ,""             ,"Local parameter STCS after clipping")
`OPP(lp_thecs          ,""             ,"Local parameter THECS after T-scaling and clipping")
`OPP(lp_stthecs        ,""             ,"Local parameter STTHECS after clipping")
`OPP(lp_xcor           ,"V^-1"         ,"Local parameter XCOR after T-scaling and clipping")
`OPP(lp_stxcor         ,""             ,"Local parameter STXCOR after clipping")
`OPP(lp_feta           ,""             ,"Local parameter FETA after clipping")
`OPP(lp_rs             ,"Ohm"          ,"Local parameter RS after T-scaling and clipping")
`OPP(lp_strs           ,""             ,"Local parameter STRS after clipping")
`OPP(lp_rsb            ,"V^-1"         ,"Local parameter RSB after clipping")
`OPP(lp_rsg            ,"V^-1"         ,"Local parameter RSG after clipping")
`OPP(lp_thesat         ,"V^-1"         ,"Local parameter THESAT after T-scaling and clipping")
`OPP(lp_thesatac       ,"V^-1"         ,"Local parameter THESATAC after T-scaling and clipping")
`OPP(lp_stthesat       ,""             ,"Local parameter STTHESAT after clipping")
`OPP(lp_thesatb        ,"V^-1"         ,"Local parameter THESATB after clipping")
`OPP(lp_thesatg        ,"V^-1"         ,"Local parameter THESATG after clipping")
`OPP(lp_ax             ,""             ,"Local parameter AX after clipping")
`OPP(lp_axac           ,""             ,"Local parameter AXAC after clipping")
`OPP(lp_alp            ,""             ,"Local parameter ALP after clipping")
`OPP(lp_alpac          ,""             ,"Local parameter ALPAC after clipping")
`OPP(lp_alp1           ,"V"            ,"Local parameter ALP1 after clipping")
`OPP(lp_alp2           ,"V^-1"         ,"Local parameter ALP2 after clipping")
`OPP(lp_vp             ,"V"            ,"Local parameter VP after clipping")
`OPP(lp_a1             ,""             ,"Local parameter A1 after clipping")
`OPP(lp_a2             ,"V"            ,"Local parameter A2 after T-scaling and clipping")
`OPP(lp_sta2           ,""             ,"Local parameter STA2 after clipping")
`OPP(lp_a3             ,""             ,"Local parameter A3 after clipping")
`OPP(lp_a4             ,"1/sqrt(V)"    ,"Local parameter A4 after clipping")
`OPP(lp_gco            ,""             ,"Local parameter GCO after clipping")
`OPP(lp_iginv          ,"A"            ,"Local parameter IGINV after T-scaling and clipping")
`OPP(lp_igov           ,"A"            ,"Local parameter IGOV after T-scaling and clipping")
`OPP(lp_igovd          ,"A"            ,"Local parameter IGOVD after T-scaling and clipping")
`OPP(lp_stig           ,""             ,"Local parameter STIG after clipping")
`OPP(lp_gc2            ,""             ,"Local parameter GC2 after clipping")
`OPP(lp_gc3            ,""             ,"Local parameter GC3 after clipping")
`OPP(lp_gc2ov          ,""             ,"Local parameter GC2OV after clipping")
`OPP(lp_gc3ov          ,""             ,"Local parameter GC3OV after clipping")
`OPP(lp_chib           ,"V"            ,"Local parameter CHIB after clipping")
`OPP(lp_agidl          ,"A/V^3"        ,"Local parameter AGIDL after clipping")
`OPP(lp_agidld         ,"A/V^3"        ,"Local parameter AGIDLD after clipping")
`OPP(lp_bgidl          ,"V"            ,"Local parameter BGIDL after T-scaling and clipping")
`OPP(lp_bgidld         ,"V"            ,"Local parameter BGIDLD after T-scaling and clipping")
`OPP(lp_stbgidl        ,"V/K"          ,"Local parameter STBGIDL after clipping")
`OPP(lp_stbgidld       ,"V/K"          ,"Local parameter STBGIDLD after clipping")
`OPP(lp_cgidl          ,""             ,"Local parameter CGIDL after clipping")
`OPP(lp_cgidld         ,""             ,"Local parameter CGIDLD after clipping")
`OPP(lp_cox            ,"F"            ,"Local parameter COX after clipping")
`OPP(lp_cgov           ,"F"            ,"Local parameter CGOV after clipping")
`OPP(lp_cgovd          ,"F"            ,"Local parameter CGOVD after clipping")
`OPP(lp_fcgovacc       ,""             ,"Local parameter FCGOVACC after clipping")
`OPP(lp_fcgovaccd      ,""             ,"Local parameter FCGOVACCD after clipping")
`OPP(lp_cgovaccg       ,""             ,"Local parameter CGOVACCG after clipping")
`OPP(lp_cgbov          ,"F"            ,"Local parameter CGBOV after clipping")
`OPP(lp_cinr           ,"F"            ,"Local parameter CINR after clipping")
`OPP(lp_cinrd          ,"F"            ,"Local parameter CINRD after clipping")
`OPP(lp_dvfbinr        ,"V"            ,"Local parameter DVFBINR after clipping")
`OPP(lp_fcinrdep       ,""             ,"Local parameter FCINRDEP after clipping")
`OPP(lp_fcinracc       ,""             ,"Local parameter FCINRACC after clipping")
`OPP(lp_axinr          ,""             ,"Local parameter AXINR after clipping")
`OPP(lp_cfr            ,"F"            ,"Local parameter CFR after clipping")
`OPP(lp_cfrd           ,"F"            ,"Local parameter CFRD after clipping")
`OPP(lp_fnt            ,""             ,"Local parameter FNT after clipping")
`OPP(lp_fntexc         ,""             ,"Local parameter FNTEXC after clipping")
`OPP(lp_nfa            ,"1/(V m^4)"    ,"Local parameter NFA after clipping")
`OPP(lp_nfb            ,"1/(V m^4)"    ,"Local parameter NFB after clipping")
`OPP(lp_nfc            ,"V^-1"         ,"Local parameter NFC after clipping")
`OPP(lp_ef             ,""             ,"Local parameter EF after clipping")
`OPP(lp_vfbedge        ,"V"            ,"Local parameter VFBEDGE after T-scaling and clipping")
`OPP(lp_stvfbedge      ,"V/K"          ,"Local parameter STVFBEDGE after clipping")
`OPP(lp_dphibedge      ,"V"            ,"Local parameter DPHIBEDGE after clipping")
`OPP(lp_neffedge       ,"m^-3"         ,"Local parameter NEFFEDGE after clipping")
`OPP(lp_ctedge         ,""             ,"Local parameter CTEDGE after clipping")
`OPP(lp_betnedge       ,"m^2/V/s"      ,"Local parameter BETNEDGE after T-scaling and clipping")
`OPP(lp_stbetedge      ,""             ,"Local parameter STBETEDGE after clipping")
`OPP(lp_psceedge       ,""             ,"Local parameter PSCEEDGE after clipping")
`OPP(lp_pscebedge      ,"V^-1"         ,"Local parameter PSCEBEDGE after clipping")
`OPP(lp_pscededge      ,"V^-1"         ,"Local parameter PSCEDEDGE after clipping")
`OPP(lp_cfedge         ,"V"            ,"Local parameter CFEDGE after clipping")
`OPP(lp_cfdedge        ,"V^-1"         ,"Local parameter CFDEDGE after clipping")
`OPP(lp_cfbedge        ,"V^-1"         ,"Local parameter CFBEDGE after clipping")
`OPP(lp_fntedge        ,""             ,"Local parameter FNTEDGE after clipping")
`OPP(lp_nfaedge        ,"1/(V m^4)"    ,"Local parameter NFAEDGE after clipping")
`OPP(lp_nfbedge        ,"1/(V m^4)"    ,"Local parameter NFBEDGE after clipping")
`OPP(lp_nfcedge        ,"V^-1"         ,"Local parameter NFCEDGE after clipping")
`OPP(lp_efedge         ,""             ,"Local parameter EFEDGE after clipping")
`OPP(lp_rg             ,"Ohm"          ,"Local parameter RG after clipping")
`OPP(lp_rse            ,"Ohm"          ,"Local parameter RSE after clipping")
`OPP(lp_rde            ,"Ohm"          ,"Local parameter RDE after clipping")
`OPP(lp_rbulk          ,"Ohm"          ,"Local parameter RBULK after clipping")
`OPP(lp_rwell          ,"Ohm"          ,"Local parameter RWELL after clipping")
`OPP(lp_rjuns          ,"Ohm"          ,"Local parameter RJUNS after clipping")
`OPP(lp_rjund          ,"Ohm"          ,"Local parameter RJUND after clipping")
`ifdef SelfHeating
    `OPP(lp_rth            ,"K/W"          ,"Local parameter RTH after T-scaling and clipping")
    `OPP(lp_cth            ,"J/K"          ,"Local parameter CTH after clipping")
    `OPP(lp_strth          ,""             ,"Local parameter STRTH after clipping")
    `OPP(pdiss             ,"W"            ,"Power dissipation")
    `OPP(dtsh              ,"K"            ,"Temperature rise due to self heating")
`endif // SelfHeating
`OPP(tk                ,"K"            ,"Device Temperature")
`OPP(cjosbot           ,"F"            ,"Bottom component of total zero-bias source junction capacitance at device temperature")
`OPP(cjossti           ,"F"            ,"STI-edge component of total zero-bias source junction capacitance at device temperature")
`OPP(cjosgat           ,"F"            ,"Gate-edge component of total zero-bias source junction capacitance at device temperature")
`OPP(vbisbot           ,"V"            ,"Built-in voltage of source-side bottom junction at device temperature")
`OPP(vbissti           ,"V"            ,"Built-in voltage of source-side STI-edge junction at device temperature")
`OPP(vbisgat           ,"V"            ,"Built-in voltage of source-side gate-edge junction at device temperature")
`OPP(idsatsbot         ,"A"            ,"Total source-side bottom junction saturation current")
`OPP(idsatssti         ,"A"            ,"Total source-side STI-edge junction saturation current")
`OPP(idsatsgat         ,"A"            ,"Total source-side gate-edge junction saturation current")
`OPP(cjosbotd          ,"F"            ,"Bottom component of total zero-bias drain junction capacitance at device temperature")
`OPP(cjosstid          ,"F"            ,"STI-edge component of total zero-bias drain junction capacitance at device temperature")
`OPP(cjosgatd          ,"F"            ,"Gate-edge component of total zero-bias drain junction capacitance at device temperature")
`OPP(vbisbotd          ,"V"            ,"Built-in voltage of drain-side bottom junction at device temperature")
`OPP(vbisstid          ,"V"            ,"Built-in voltage of drain-side STI-edge junction at device temperature")
`OPP(vbisgatd          ,"V"            ,"Built-in voltage of drain-side gate-edge junction at device temperature")
`OPP(idsatsbotd        ,"A"            ,"Total drain-side bottom junction saturation current")
`OPP(idsatsstid        ,"A"            ,"Total drain-side STI-edge junction saturation current")
`OPP(idsatsgatd        ,"A"            ,"Total drain-side gate-edge junction saturation current")
`ifdef NQSmodel
    `OPP(lp_munqs          ,""             ,"Local parameter MUNQS after clipping")
`endif // NQSmodel

//  --------------------------------------------------------------------------------------------------------------
//  Analog block with all calculations and contribs
//  --------------------------------------------------------------------------------------------------------------
analog begin

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of bias/instance independent model variables
    //  --------------------------------------------------------------------------------------------------------------
    begin : initial_model

        //  Clipping and rounding of switch parameters
        if (TYPE >= 0) begin
            CHNL_TYPE   = `NMOS;
        end else begin
            CHNL_TYPE   = `PMOS;
        end
        EPSSI       = `EPSO * `EPSRSI;
        `ifdef NQSmodel
            if (SWNQS < 0.5) begin
                SWNQS_i     =  0;
            end else begin
                if (SWNQS < 1.5) begin
                    SWNQS_i     =  1;
                end else begin
                    if (SWNQS < 2.5) begin
                        SWNQS_i     =  2;
                    end else begin
                        if (SWNQS < 4.0) begin
                            SWNQS_i     =  3;
                        end else begin
                            if (SWNQS < 7.0) begin
                                SWNQS_i     =  5;
                            end else begin
                                SWNQS_i     =  9;
                            end
                        end
                    end
                end
            end
            r_nqs       =  1.0e3;
            vnorm       =  10.0;
            vnorm_inv   =  1.0 / vnorm;
        `endif // NQSmodel

        //  Definition of global-binning parameters for the charge model in the case of separate calculation in saturation
        `DefACparam(CFACL_i,        CFL,        CFACL)
        `DefACparam(CFACLEXP_i,     CFLEXP,     CFACLEXP)
        `DefACparam(CFACW_i,        CFW,        CFACW)
        `DefACparam(THESATACO_i,    THESATO,    THESATACO)
        `DefACparam(THESATACL_i,    THESATL,    THESATACL)
        `DefACparam(THESATACLEXP_i, THESATLEXP, THESATACLEXP)
        `DefACparam(THESATACW_i,    THESATW,    THESATACW)
        `DefACparam(THESATACLW_i,   THESATLW,   THESATACLW)
        `DefACparam(AXACO_i,        AXO,        AXACO)
        `DefACparam(AXACL_i,        AXL,        AXACL)
        `DefACparam(ALPACL_i,       ALPL,       ALPACL)
        `DefACparam(ALPACLEXP_i,    ALPLEXP,    ALPACLEXP)
        `DefACparam(ALPACW_i,       ALPW,       ALPACW)
        `DefACparam(POCFAC_i,       POCF,       POCFAC)
        `DefACparam(PLCFAC_i,       PLCF,       PLCFAC)
        `DefACparam(PWCFAC_i,       PWCF,       PWCFAC)
        `DefACparam(PLWCFAC_i,      PLWCF,      PLWCFAC)
        `DefACparam(POTHESATAC_i,   POTHESAT,   POTHESATAC)
        `DefACparam(PLTHESATAC_i,   PLTHESAT,   PLTHESATAC)
        `DefACparam(PWTHESATAC_i,   PWTHESAT,   PWTHESATAC)
        `DefACparam(PLWTHESATAC_i,  PLWTHESAT,  PLWTHESATAC)
        `DefACparam(POAXAC_i,       POAX,       POAXAC)
        `DefACparam(PLAXAC_i,       PLAX,       PLAXAC)
        `DefACparam(PWAXAC_i,       PWAX,       PWAXAC)
        `DefACparam(PLWAXAC_i,      PLWAX,      PLWAXAC)
        `DefACparam(POALPAC_i,      POALP,      POALPAC)
        `DefACparam(PLALPAC_i,      PLALP,      PLALPAC)
        `DefACparam(PWALPAC_i,      PWALP,      PWALPAC)
        `DefACparam(PLWALPAC_i,     PLWALP,     PLWALPAC)
        `DefACparam(KVSATAC_i,      KVSAT,      KVSATAC)

        //  Transistor temperature
        TKR         = `KELVINCONVERSION + TR;
        TKA         =  $temperature + DTA;
        rTa         =  TKA / TKR;
        delTa       =  TKA - TKR;
        phita       =  TKA * `KBOL / `QELE;
        inv_phita   =  1.0 / phita;
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            TKD         =  TKA;
            `TempInitialize
        `endif // SelfHeating

        // JUNCAP2
        `include "JUNCAP200_InitModel.include"

        //  Gmin definition
        gmin        =  $simparam("gmin",0.0);

    end // initial_model

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of instance dependent and bias independent variables
    //  --------------------------------------------------------------------------------------------------------------
    begin : initial_instance

        //  Declaration of local variables
        real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
        real temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

        //  Instance variables
        NF_i        =  1.0;
        invNF       =  1.0;
        LE          =  0.0;
        WE          =  0.0;
        L_i         =  L;
        W_i         =  W;
        SA_i        =  SA;
        SB_i        =  SB;
        SD_i        =  SD;
        SC_i        =  SC;
        XGW_i       =  XGW;
        ABSOURCE_i  =  ABSOURCE;
        LSSOURCE_i  =  LSSOURCE;
        LGSOURCE_i  =  LGSOURCE;
        ABDRAIN_i   =  ABDRAIN;
        LSDRAIN_i   =  LSDRAIN;
        LGDRAIN_i   =  LGDRAIN;
        AS_i        =  AS;
        PS_i        =  PS;
        AD_i        =  AD;
        PD_i        =  PD;
        JW_i        =  JW;

        //  Clipping of the instance parameters
        if ((SWGEO == 1) || (SWGEO == 2)) begin
            NF_i        = `CLIP_LOW(NF, 1.0);
            NF_i        =  floor(NF_i + 0.5); // round to nearest integer
            invNF       =  1.0 / NF_i;
        end
        W_i          = `CLIP_LOW(W_i * invNF, 1.0e-9);
        SCA_i        =  SCA;
        SCB_i        =  SCB;
        SCC_i        =  SCC;
        NGCON_i      =  (NGCON < 1.5) ? 1.0 : 2.0;

        //  Internal local parameters
        `include "PSP103_scaling.include"

        //  Local process variables
        EPSOX        = `EPSO * EPSROX_i;
        CoxPrime     =  EPSOX / TOX_i;
        tox_sq       =  TOX_i * TOX_i;
        Cox_over_q   =  CoxPrime / `QELE;
        NEFFAC_i     =  FACNEFFAC_i * NEFF_i;
        NEFFAC_i     = `CLIP_BOTH(NEFFAC_i, 1.0e20, 1.0e26);

        //  QM corrections
        qq           =  0.0;
        if (QMC > 0.0) begin
            qq           =  0.4 * `QMN * QMC * pow(CoxPrime, `twoThirds);
            if (CHNL_TYPE==`PMOS) begin
                qq           = `QMP / `QMN * qq;
            end
        end

        //  Electrical field variables
        E_eff0       =  1.0e-8 * CoxPrime / EPSSI;
        eta_mu       =  0.5 * FETA_i;
        eta_mu1      =  0.5;
        if (CHNL_TYPE == `PMOS) begin
            eta_mu       =  `oneThird * FETA_i;
            eta_mu1      =  `oneThird;
        end

        //  Linear-saturation transition variable
        inv_AX       =  1.0 / AX_i;

        //  CLM variable
        inv_VP       =  1.0 / VP_i;

        //  Gate overlap variables
        CoxovPrime   =  EPSOX / TOXOV_i;
        CoxovPrime_d =  EPSOX / TOXOVD_i;
        GOV_s        =  sqrt(2.0 * `QELE * NOV_i * EPSSI * inv_phita) / CoxovPrime;
        GOV_d        =  sqrt(2.0 * `QELE * NOVD_i * EPSSI * inv_phita) / CoxovPrime_d;
        GOV2_s       =  GOV_s * GOV_s;
        GOV2_d       =  GOV_d * GOV_d;
        dxgb_ov_th   =  ln(exp(CGOVACCG_i * 0.005 * inv_phita) - 1.0) / CGOVACCG_i - ln(exp(0.005 * inv_phita) - 1.0);
        dxgb_ov_s    =  ln(0.5 * GOV_s) + dxgb_ov_th;
        dxgb_ov_d    =  ln(0.5 * GOV_d) + dxgb_ov_th;
        `sp_ovInit(GOV_s, GOV2_s, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s)
        `sp_ovInit(GOV_d, GOV2_d, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d)

        //  Temperature scaling variables
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            `TempScaling
        `endif // SelfHeating

        //  Gate to channel leakage variables
        inv_CHIB     =  1.0 / CHIB_i;
        B_fact       =  4.0 * `oneThird * sqrt(2.0 * `QELE * `MELE * CHIB_i) / `HBAR;
        BCH          =  B_fact * TOX_i;
        BOV          =  B_fact * TOXOV_i;
        BOV_d        =  B_fact * TOXOVD_i;
        GCQ          =  0.0;
        if (GC3_i < 0.0) begin
            GCQ          =  -0.495 * GC2_i / GC3_i;
        end
        GCQOV        =  GCQ;
        if (SWIGATE == 2) begin
            GCQOV          =  0.0;
            if (GC3OV_i < 0.0) begin
                GCQOV          =  -0.495 * GC2OV_i / GC3OV_i;
            end
        end
        tf_ig        =  pow(rTa, STIG_i);
        IGINV_i      =  IGINV_i * tf_ig;
        IGOV_i       =  IGOV_i * tf_ig;
        IGOVD_i      =  IGOVD_i * tf_ig;

        //  GIDL variables
        AGIDLs       =  AGIDL_i * 4.0e-18 / (TOXOV_i * TOXOV_i);
        AGIDLDs      =  AGIDLD_i * 4.0e-18 / (TOXOVD_i * TOXOVD_i);
        B_fact       = `MAX(1.0 + STBGIDL_i * delTa, 0.0);
        BGIDL_T      =  BGIDL_i * B_fact;
        BGIDLs       =  BGIDL_T * TOXOV_i * 5.0e8;
        B_fact       = `MAX(1.0 + STBGIDLD_i * delTa, 0.0);
        BGIDLD_T     =  BGIDLD_i * B_fact;
        BGIDLDs      =  BGIDLD_T * TOXOVD_i * 5.0e8;

        //  Inner fringe charge variables
        Vinr_max     =  0.0;
        if (FCINRACC_i > 1.0e-10) begin
            Vinr_max     =  0.75 / FCINRACC_i;
        end
        ainr         =  AXINR_i * AXINR_i;

        //  Self Heating variables
        `ifdef SelfHeating
            RTH_T        =  RTH_i * pow(rTa, STRTH_i);
        `endif // SelfHeating

        //  Noise model variables
        fac_exc      = `MELE * 1.0e9 * FNTEXC_i;

        //  Conductance of parasitic resistances
        if (RG_i > 0.0) begin
            ggate        =  1.0 / RG_i;
        end else begin
            ggate        =  0.0;
        end
        if (RSE_i > 0.0) begin
            gsource      =  1.0 / RSE_i;
        end else begin
            gsource      =  0.0;
        end
        if (RDE_i > 0.0) begin
            gdrain       =  1.0 / RDE_i;
        end else begin
            gdrain       =  0.0;
        end
        if (RBULK_i > 0.0) begin
            gbulk        =  1.0 / RBULK_i;
        end else begin
            gbulk        =  0.0;
        end
        if (RJUNS_i > 0.0) begin
            gjuns        =  1.0 / RJUNS_i;
        end else begin
            gjuns        =  0.0;
        end
        if (RJUND_i > 0.0) begin
            gjund        =  1.0 / RJUND_i;
        end else begin
            gjund        =  0.0;
        end
        if (RWELL_i > 0.0) begin
            gwell        =  1.0 / RWELL_i;
        end else begin
            gwell        =  0.0;
        end

        //  JUNCAP instance variables
        ABS_i        =  0.0;
        LSS_i        =  0.0;
        LGS_i        =  0.0;
        ABD_i        =  0.0;
        LSD_i        =  0.0;
        LGD_i        =  0.0;
        jwcorr       =  0.0;
        jww          =  WE;
        if (SWGEO == 0) begin
            jww          = `CLIP_LOW(JW_i, `LG_cliplow);
        end
        if (SWJUNCAP == 3) begin
            jwcorr       =  1.0;
        end
        ABS_i        =  ABSOURCE_i * invNF;
        LSS_i        =  LSSOURCE_i * invNF;
        LGS_i        =  LGSOURCE_i * invNF;
        ABD_i        =  ABDRAIN_i * invNF;
        LSD_i        =  LSDRAIN_i * invNF;
        LGD_i        =  LGDRAIN_i * invNF;
        if ((SWJUNCAP == 2) || (SWJUNCAP == 3)) begin
            ABS_i        =  AS_i * invNF;
            LSS_i        =  PS_i * invNF - jwcorr * jww;
            LGS_i        =  jww;
            ABD_i        =  AD_i * invNF;
            LSD_i        =  PD_i * invNF - jwcorr * jww;
            LGD_i        =  jww;
        end
        if ((SWJUNCAP == 1) || (SWJUNCAP == 2) || (SWJUNCAP == 3)) begin
            ABSOURCE_i   = `CLIP_LOW(ABS_i, `AB_cliplow);
            LSSOURCE_i   = `CLIP_LOW(LSS_i, `LS_cliplow);
            LGSOURCE_i   = `CLIP_LOW(LGS_i, `LG_cliplow);
            ABDRAIN_i    = `CLIP_LOW(ABD_i, `AB_cliplow);
            LSDRAIN_i    = `CLIP_LOW(LSD_i, `LS_cliplow);
            LGDRAIN_i    = `CLIP_LOW(LGD_i, `LG_cliplow);
        end else begin
            ABSOURCE_i   =  0.0;
            LSSOURCE_i   =  0.0;
            LGSOURCE_i   =  0.0;
            ABDRAIN_i    =  0.0;
            LSDRAIN_i    =  0.0;
            LGDRAIN_i    =  0.0;
        end

        //  Initialization of JUNCAP (global) variables; required for some verilog-A compilers
        vbimin_s     =  0.0;
        vbimin_d     =  0.0;
        vfmin_s      =  0.0;
        vfmin_d      =  0.0;
        vch_s        =  0.0;
        vch_d        =  0.0;
        vbbtlim_s    =  0.0;
        vbbtlim_d    =  0.0;
        VMAX_s       =  0.0;
        VMAX_d       =  0.0;
        exp_VMAX_over_phitd_s =  0.0;
        exp_VMAX_over_phitd_d =  0.0;
        ISATFOR1_s   =  0.0;
        ISATFOR1_d   =  0.0;
        MFOR1_s      =  1.0;
        MFOR1_d      =  1.0;
        ISATFOR2_s   =  0.0;
        ISATFOR2_d   =  0.0;
        MFOR2_s      =  1.0;
        MFOR2_d      =  1.0;
        ISATREV_s    =  0.0;
        ISATREV_d    =  0.0;
        MREV_s       =  1.0;
        MREV_d       =  1.0;
        m0flag_s     =  0.0;
        m0flag_d     =  0.0;
        xhighf1_s    =  0.0;
        xhighf1_d    =  0.0;
        expxhf1_s    =  0.0;
        expxhf1_d    =  0.0;
        xhighf2_s    =  0.0;
        xhighf2_d    =  0.0;
        expxhf2_s    =  0.0;
        expxhf2_d    =  0.0;
        xhighr_s     =  0.0;
        xhighr_d     =  0.0;
        expxhr_s     =  0.0;
        expxhr_d     =  0.0;
        zflagbot_s   =  1.0;
        zflagbot_d   =  1.0;
        zflagsti_s   =  1.0;
        zflagsti_d   =  1.0;
        zflaggat_s   =  1.0;
        zflaggat_d   =  1.0;
        m0_rev       =  0.0;
        mcor_rev     =  0.0;
        I1_cor       =  0.0;
        I2_cor       =  0.0;
        I3_cor       =  0.0;
        I4_cor       =  0.0;
        I5_cor       =  0.0;
        tt0          =  0.0;
        tt1          =  0.0;
        tt2          =  0.0;
        zfrac        =  0.0;
        alphaje      =  0.0;

        if (SWJUNCAP > 0) begin
            `JuncapInitInstance(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot,   idsatsti,   idsatgat,   vbibot,   vbisti,   vbigat,   PBOT,  PSTI,  PGAT,  VBIRBOT,  VBIRSTI, VBIRGAT,  VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
            `JuncapInitInstance(ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  idsatbot_d, idsatsti_d, idsatgat_d, vbibot_d, vbisti_d, vbigat_d, PBOTD_i, PSTID_i, PGATD_i, VBIRBOTD_i, VBIRSTID_i, VBIRGATD_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)

            if (SWJUNEXP_i == 1) begin : JUNCAPexpressInit
                // Local variable declaration
                `LocalGlobalVars

                real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

                //  Initialization of (local) variables; required for some verilog-A compilers
                `JuncapLocalVarInit

                //  Computation of JUNCAP-express internal variables for source side
                `JuncapExpressInit1(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VJUNREF, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit2(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit3(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot, idsatsti, idsatgat, ISATFOR1_s, MFOR1_s, ISATFOR2_s, MFOR2_s, ISATREV_s, MREV_s, m0flag_s)
                `JuncapExpressInit4(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, FJUNQ, cjobot, cjosti, cjogat, zflagbot_s, zflagsti_s, zflaggat_s)
                `JuncapExpressInit5(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, ISATFOR2_s, ISATREV_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s)

                //  Computation of JUNCAP-express internal variables for drain side
                `JuncapExpressInit1(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VJUNREFD_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit2(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit3(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, idsatbot_d, idsatsti_d, idsatgat_d, ISATFOR1_d, MFOR1_d, ISATFOR2_d, MFOR2_d, ISATREV_d, MREV_d, m0flag_d)
                `JuncapExpressInit4(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, FJUNQD_i, cjobot_d, cjosti_d, cjogat_d, zflagbot_d, zflagsti_d, zflaggat_d)
                `JuncapExpressInit5(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, ISATFOR2_d, ISATREV_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d)
            end // JUNCAPexpressInit

        end

    end // initial_instance

    begin : evaluateblock

        real sigVds, dphit1, xgct, xsct0, xbct, xsbstar, xsct, dCTG, ct_fact, phit1, inv_phit1, Vgb1_dc, xg_dc, alpha_dc, dps_dc, qim_dc;
        real qim1_dc, H_dc, FdL_dc, Gvsatinv_dc, Ids, Iimpact, mavl, Igdov, Igsov, Igcd, Igcs, eta_p_ac, Gvsat_ac, Gmob_dL_ac, Vgsinr_ac;
        real Vsginr_ac, Vgdinr_ac, Vdginr_ac, H0, COX_qm, ijun_s, ijunbot_s, ijunsti_s, ijungat_s, ijun_d, ijunbot_d, ijunsti_d, ijungat_d;
        real qjun_s, qjunbot_s, qjunsti_s, qjungat_s, qjun_d, qjunbot_d, qjunsti_d, qjungat_d, jnoise_s, jnoise_d, Gmob_dc, xitsb_dc;
        real Vdse_dc, Vgsinr_dc, Vsginr_dc, Vgdinr_dc, Vdginr_dc, Vsbstaredge, Vsbxedge, dphit1edge, phit1edge, inv_phit1edge, Vdspedge;
        real delVgedge, xgedge, xbedge, dxthedge, xnedge_s, qseffedge, xnedge_d, qdseffedge, qdeffedge, qmeffedge, dsqredge, alphabmedge;
        real Idsedge, Sfledge, midedge, sqidedge;
        `ifdef SelfHeating
            real Pdiss, phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
            real ntedge;
        `endif // SelfHeating
        real temp, temp1, temp2;

        //  --------------------------------------------------------------------------------------------------------------
        //  DC bias dependent quantities (calculations for current contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStatic

            //  Initialize temporary variables
            temp        =  0.0;
            temp1       =  0.0;
            temp2       =  0.0;

            //  Initialization of variables for SHE effect
            `ifdef SelfHeating
                TKD          =  TKA + Temp(br_rth);
                `TempInitialize
                `TempScaling
            `endif // SelfHeating
            QCLM         =  0.0;
            xs_ov        =  0.0;
            xd_ov        =  0.0;
            Vovs         =  0.0;
            Vovd         =  0.0;
            Iimpact      =  0.0;
            mavl         =  0.0;

            //  Initialization of variables for NQS model
            `ifdef NQSmodel
                pd           =  1.0;
                ym           =  0.0;
            `endif // NQSmodel

            //  Voltage affectations
            if (CHNL_TYPE == `NMOS) begin
                Vgs          =  V(GP, SI);
                Vds          =  V(DI, SI);
                Vsb          =  V(SI, BP);
                Vjun_s       = -V(SI, BS);
                Vjun_d       = -V(DI, BD);
            end else begin
                Vgs          = -V(GP, SI);
                Vds          = -V(DI, SI);
                Vsb          = -V(SI, BP);
                Vjun_s       =  V(SI, BS);
                Vjun_d       =  V(DI, BD);
            end
            Vgb          =  Vgs + Vsb;

            //  Voltages NOT subject to S/D-interchange
            VgsPrime     =  Vgs;
            VsbPrime     =  Vsb;
            VdbPrime     =  Vds + Vsb;
            VgdPrime     =  Vgs - Vds;

            //  Voltages for overlaps
            xgs_ov       = -VgsPrime * inv_phita;
            xgd_ov       = -VgdPrime * inv_phita;
            xgb_ov       = -(Vgb - VFB_T) * inv_phita;

            //  Source-drain interchange
            sigVds       =  1.0;
            if (Vds < 0.0) begin
                sigVds       = -1.0;
                Vgs          =  Vgs - Vds;
                Vsb          =  Vsb + Vds;
                Vds          = -Vds;
            end
            Vdb          =  Vds + Vsb;
            Vdsx         =  Vds * Vds / (sqrt(Vds * Vds + 0.01) + 0.1);

            //  Core's model calculation for DC
            begin : SPcalc_dc

                //  Local variable declaration
                `SPcalcLocalVarDecl
                real FdL, qim1_1, r1, r2, s2, dL1;

                //  Conditioning of terminal voltages
                temp         = `MINA(Vdb, Vsb, bphi_dc) + phix_dc;
                Vsbstar_dc   =  Vsb - `MINA(temp, 0, aphi_dc) + phix1_dc;
                Vsbstar_dc_tmp = Vsbstar_dc;

                //  Adapt Vsb for NUD-effect
                if ((SWNUD != 0) && (GFACNUD_i != 1.0)) begin
                    Vmb          =  Vsbstar_dc + 0.5 * (Vds - Vdsx);
                    us           =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                    temp         =  2.0 * (us - us1) / us21 - 1.0;
                    usnew        =  us - 0.25 * (1.0 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                    Vmbnew       =  usnew * usnew + (2.0 * sqrt_phib_dc) * usnew;
                    Vsbstar_dc   =  Vmbnew - 0.5 * (Vds - Vdsx);
                end

                //  Set variables needed in PSP_core macro
                phib         =  phib_dc;
                G_0          =  G_0_dc;
                Vsbstar      =  Vsbstar_dc;
                cfloc        =  CF_i;
                thesatloc    =  THESAT_T;
                axloc        =  AX_i;
                alploc       =  ALP_i;
                FdL          =  1.0;

                //  Calculation of PSP model's core
                `SPCalculation

                if (xg > 0.0) begin
                    qim1_1       =  1.0 / qim1;
                    r1           =  qim * qim1_1;
                    r2           =  phit1 * (alpha * qim1_1);
                    s2           =  ln(1.0 + Vdsx * inv_VP);
                    dL1          =  dL + ALP1_i * (qim1_1 * r1 * s1) + ALP2_i * (qbm * r2 * r2 * s2);
                    FdL          =  (1.0 + dL1 + dL1 * dL1) * GdL;
                end

                Vgb1_dc      =  Vgb1;
                xg_dc        =  xg;
                qeff1_dc     =  qeff1;
                Voxm_dc      =  Voxm;
                alpha_dc     =  alpha;
                dps_dc       =  dps;
                qim_dc       =  qim;
                qim1_dc      =  qim1;
                GdL_dc       =  GdL;
                FdL_dc       =  FdL;
                H_dc         =  H;
                eta_p_dc     =  eta_p;
                Gvsat_dc     =  Gvsat;
                Gvsatinv_dc  =  Gvsatinv;
                Gmob_dL_dc   =  Gmob_dL;
                x_ds_dc      =  x_ds;
                x_m_dc       =  x_m;
                Gf_dc        =  Gf;
                Vdsat_dc     =  Vdsat;
                Udse_dc      =  Udse;
                Gmob_dc      =  Gmob;
                xitsb_dc     =  xitsb;
                Vdse_dc      =  Vdse;
                Vgsinr_dc    =  Vgsinr;
                Vsginr_dc    =  Vsginr;
                Vgdinr_dc    =  Vgdinr;
                Vdginr_dc    =  Vdginr;
                `ifdef NQSmodel
                    xgm_dc       =  xgm;
                    thesat1_dc   =  thesat1;
                    margin_dc    =  margin;
                `endif // NQSmodel
            end // SPcalc_dc

            if (xg_dc <= 0.0) begin
                Ids          =  0.0;
            end else begin
                //  Drain-source current
                Ids          =  BET_i * (FdL_dc * qim1_dc * dps_dc * Gvsatinv_dc);
            end

            //  Surface potential in gate overlap regions
            if (((SWIGATE != 0) && ((IGOV_i > 0.0) || (IGOVD_i > 0.0))) || ((SWGIDL != 0) && ((AGIDL_i > 0.0) || (AGIDLD_i > 0.0))) || (CGOV_i > 0.0) || (CGOVD_i > 0.0)) begin
                SP_OV_xg     = 0.5 * (xgs_ov + sqrt(xgs_ov * xgs_ov + SP_OV_eps2_s));
                xs_ov        = -SP_OV_xg - GOV2_s * 0.5 + GOV_s * sqrt(SP_OV_xg + GOV2_s * 0.25 + SP_OV_a_s) + SP_OV_delta1_s;
                SP_OV_xg     = 0.5 * (xgd_ov + sqrt(xgd_ov * xgd_ov + SP_OV_eps2_d));
                xd_ov        = -SP_OV_xg - GOV2_d * 0.5 + GOV_d * sqrt(SP_OV_xg + GOV2_d * 0.25 + SP_OV_a_d) + SP_OV_delta1_d;
                Vovs         = -phita * (xgs_ov + xs_ov);
                Vovd         = -phita * (xgd_ov + xd_ov);
            end

            //  Gate current
            Igsov        =  0.0;
            Igdov        =  0.0;
            Igc          =  0.0;
            Igb          =  0.0;
            Igcs         =  0.0;
            Igcd         =  0.0;
            if (SWIGATE != 0) begin
                if (IGOV_i > 0.0) begin
                    //  Gate-source overlap component of gate current
                    zg           =  sqrt(Vovs * Vovs + 1.0e-6) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-6);
                    end
                    temp         =  BOV * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xs_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgsPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igsov        =  IGOV_i * (TP * Fs);
                end

                if (IGOVD_i > 0.0) begin
                    //  Gate-drain overlap component of gate current
                    zg           =  sqrt(Vovd * Vovd + 1.0e-6) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-6);
                    end
                    temp         =  BOV_d * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xd_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgdPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igdov        =  IGOVD_i * (TP * Fs);
                end

                //  Gate-channel component of gate current
                if (IGINV_i > 0.0) begin
                    if (xg_dc <= 0.0) begin
                        temp         =  pow(Vds / Vdsat_lim, AX_i);
                        Udse_dc      =  Vds * pow(1.0 + temp, -inv_AX) * inv_phit1;
                    end
                    `expl_low(x_ds_dc-Udse_dc, temp)
                    Vm           =  Vsbstar_dc + phit1 * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));
                    Dch          =  GCO_i * phit1;
                    arg2mina     =  Voxm_dc + Dch;
                    psi_t        = `MINA(0.0, arg2mina, 0.01);
                    zg           =  sqrt(Voxm_dc * Voxm_dc + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-06);
                    end
                    arg1         =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1);
                    `expl(arg1,Dsi)
                    arg1         = -(Vgs + Vsbstar_dc - Vm) * inv_phit1;
                    `expl(arg1,temp)
                    Dgate        =  Dsi * temp;
                    temp         =  BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igc0         =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

                    //  Source/drain partitioning of gate-channel current
                    if ((xg_dc <= 0.0) || ((GC2_i == 0.0) && (GC3_i == 0.0))) begin
                        igc          =  1.0;
                        igcd_h       =  0.5;
                    end else begin
                        temp         =  GC2_i + 2.0 * GC3_i * zg;
                        u0           =  CHIB_i / (temp * BCH);
                        x            =  0.5 * (dps_dc / u0);
                        u0_div_H     =  u0 / H_dc;
                        Bg           =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                        Ag           =  0.5 - 3.0 * Bg;
                        if (x < 1.0e-3) begin
                            xsq          =  x * x;
                            igc          =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                            igcd_h       =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                        end else begin
                            inv_x        =  1.0 / x;
                            `expl(x, ex)
                            inv_ex       =  1.0 / ex;
                            temp         =  ex - inv_ex;
                            temp2        =  ex + inv_ex;
                            igc          =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                            igcd_h       =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                        end
                    end
                    Sg           =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-6));
                    Igc          =  Igc0 * igc * Sg;
                    Igcd         =  Igc0 * igcd_h * Sg;
                    Igcs         =  Igc - Igcd;
                    Igb          =  Igc0 * igc * (1.0 - Sg);
                end // (IGINV >0.0)
            end // (SWIGATE != 0)

            //  GIDL/GISL currents
            Igidl        =  0.0;
            Igisl        =  0.0;
            if (SWGIDL != 0) begin
                //  GIDL current computation
                if ((AGIDLD_i > 0.0) && (Vovd < 0.0)) begin
                    Vtovd        =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                    temp         = -BGIDLDs / Vtovd;
                    `expl_low(temp, temp2)
                    Igidl        = -AGIDLDs * (VdbPrime * Vovd * Vtovd * temp2);
                end

                //  GISL current computation
                if ((AGIDL_i > 0.0) && (Vovs < 0.0)) begin
                    Vtovs        =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-6);
                    temp         = -BGIDLs / Vtovs;
                    `expl_low(temp, temp2)
                    Igisl        = -AGIDLs * (VsbPrime * Vovs * Vtovs * temp2);
                end
            end // (SWGIDL != 0)

            //  Drain current of edge transistors
            xgedge       =  0.0;
            qdseffedge   =  0.0;
            qmeffedge    =  0.0;
            dsqredge     =  1.0e-40;
            alphabmedge  =  1.0;
            Idsedge      =  0.0;
            if ((SWEDGE != 0) && (BETNEDGE_i > 0.0)) begin
                temp         = `MINA(Vdb, Vsb, bphiedge) + phixedge;
                Vsbstaredge  =  Vsb - `MINA(temp, 0.0, aphiedge) + phix1edge;
                Vsbxedge     =  Vsbstaredge + 0.5 * (Vds - Vdsx);
                dphit1edge   =  PSCEEDGE_i * (1.0 + PSCEDEDGE_i * Vdsx)* (1.0 + PSCEBEDGE_i * Vsbxedge); // SCE on subthreshold slope
                phit1edge    =  phit0edge * (1.0 + dphit1edge);
                inv_phit1edge =  1.0 / phit1edge;
                Vdspedge     =  2.0 * Vdsx / (1.0 + sqrt(1.0 + CFDEDGE_i * Vdsx));
                delVgedge    =  CFEDGE_i * Vdspedge * (1.0 + CFBEDGE_i * Vsbxedge); // DIBL effect
                xgedge       =  inv_phit1edge * (Vgs + Vsbstaredge + delVgedge - VFBEDGE_T);
                xbedge       =  inv_phit1edge * phibedge;
                dxthedge     =  2.0 * ln(xbedge / Gfedge + sqrt(xbedge));
                xnedge_s     =  inv_phit1edge * Vsbstaredge;
                `qi_edge(qseffedge,xgedge,xnedge_s)
                xnedge_d     =  inv_phit1edge * (Vdse_dc + Vsbstaredge);
                if ((qseffedge < 1.0e-3) && (Vdse_dc < 1.0e-6)) begin
                    `expl_low((-xnedge_d + xnedge_s), temp)
                    qdseffedge   =  qseffedge * (temp - 1.0);
                    qdeffedge    =  qdseffedge + qseffedge;
                end else begin
                    `qi_edge(qdeffedge,xgedge,xnedge_d)
                    qdseffedge   =  qdeffedge - qseffedge;
                end
                qmeffedge    =  0.5 * (qdeffedge + qseffedge);
                dsqredge     =  max(xgedge - qmeffedge, 1.0e-40);
                alphabmedge  =  1.0 - 0.5 * Gfedge / sqrt(dsqredge + 0.25 * Gfedge2);
                Idsedge      = -BETEDGE_i * phit1edge * phit1edge * (alphabmedge * qmeffedge  + 1.0) * qdseffedge / Gmob_dc;
            end

            //  Impact-Ionization current
            if ((xg_dc > 0.0) && (SWIMPACT != 0)) begin
                delVsat      =  Vds - A3_i * dps_dc;
                if (delVsat > 0.0) begin
                    temp2        =  A2_T * ((1.0 + A4_i * (sqrt(phib_dc + Vsbstar_dc) - sqrt_phib_dc)) / (delVsat + 1.0e-30));
                    `expl(-temp2, temp)
                    mavl         =  A1_i * (delVsat * temp);
                    Iimpact      =  mavl * (Ids + Idsedge);
                end
            end

            //  Threshold voltage calculation for .OP
            P_D          =  1.0 + 0.25 * (Gf_dc * kp);
            facvsb0      =  phib_dc + 2.0 * phit1;
            facvsb       =  Vsbstar_dc + facvsb0;
            vts_i        =  VFB_T + P_D * facvsb - Vsbstar_dc + Gf_dc * sqrt(phit1 * facvsb );
            vth_i        =  vts_i - delVg;

        end // evaluateStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  AC bias dependent quantities (calculations for charge contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateDynamic

            real Vginr , Vginreff, fqinr, dVinracc, finracc, xginrdep, finrdep, dVinrdep, finr, dVinr, xgbeff_ov_s;
            real yb_ov_s, xgbeff_ov_d, yb_ov_d;
            //  Core's model calculation for AC
            begin : SPcalc_ac

                //  Local variable declaration
                `SPcalcLocalVarDecl

                //  SP calculations
                if ((SWNUD == 1) || (SWDELVTAC != 0) || (SWQSAT == 1)) begin

                    Vsbstar      =  Vsbstar_dc_tmp;
                    phib         =  phib_dc;
                    G_0          =  G_0_dc;
                    cfloc        =  CF_i;
                    thesatloc    =  THESAT_T;
                    axloc        =  AX_i;
                    alploc       =  ALP_i;

                    if (SWDELVTAC != 0) begin
                        //  Conditioning of terminal voltages
                        temp         = `MINA(Vdb, Vsb, bphi_ac) + phix_ac;
                        Vsbstar_ac   =  Vsb - `MINA(temp, 0.0, aphi_ac) + phix1_ac;
                        Vsbstar      =  Vsbstar_ac;
                        phib         =  phib_ac;
                        G_0          =  G_0_ac;
                    end

                    if (SWQSAT != 0) begin
                        cfloc        =  CFAC_i;
                        thesatloc    =  THESATAC_T;
                        axloc        =  AXAC_i;
                        alploc       =  ALPAC_i;
                    end

                    //  Calculation of PSP model's core
                    `SPCalculation

                    Vgb1_ac      =  Vgb1;
                    xg_ac        =  xg;
                    qeff1_ac     =  qeff1;
                    Voxm_ac      =  Voxm;
                    alpha_ac     =  alpha;
                    dps_ac       =  dps;
                    qim_ac       =  qim;
                    GdL_ac       =  GdL;
                    H_ac         =  H;
                    eta_p_ac     =  eta_p;
                    Gvsat_ac     =  Gvsat;
                    Gmob_dL_ac   =  Gmob_dL;
                    Gf_ac        =  Gf;
                    Vgsinr_ac    =  Vgsinr;
                    Vsginr_ac    =  Vsginr;
                    Vgdinr_ac    =  Vgdinr;
                    Vdginr_ac    =  Vdginr;
                    `ifdef NQSmodel
                        x_m_ac       =  x_m;
                        xgm_ac       =  xgm;
                        thesat1_ac   =  thesat1;
                        margin_ac    =  margin;
                    `endif // NQSmodel
                end else begin
                    Vgb1_ac      =  Vgb1_dc;
                    xg_ac        =  xg_dc;
                    qeff1_ac     =  qeff1_dc;
                    Voxm_ac      =  Voxm_dc;
                    alpha_ac     =  alpha_dc;
                    dps_ac       =  dps_dc;
                    qim_ac       =  qim_dc;
                    GdL_ac       =  GdL_dc;
                    H_ac         =  H_dc;
                    eta_p_ac     =  eta_p_dc;
                    Gvsat_ac     =  Gvsat_dc;
                    Gmob_dL_ac   =  Gmob_dL_dc;
                    Gf_ac        =  Gf_dc;
                    Vgsinr_ac    =  Vgsinr_dc;
                    Vsginr_ac    =  Vsginr_dc;
                    Vgdinr_ac    =  Vgdinr_dc;
                    Vdginr_ac    =  Vdginr_dc;
                    `ifdef NQSmodel
                        x_m_ac       =  x_m_dc;
                        xgm_ac       =  xgm_dc;
                        thesat1_ac   =  thesat1_dc;
                        margin_ac    =  margin_dc;
                    `endif // NQSmodel
                end
            end // SPcalc_ac

            //  Quantum mechanical corrections
            COX_qm       =  COX_i;
            if (qq > 0.0) begin
                COX_qm       =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
            end

            //  Intrinsic charge model
            if (xg_ac <= 0.0) begin
                QG           =  Voxm_ac;
                QI           =  0.0;
                QD           =  0.0;
                QB           =  QG;
            end else begin
                Fj           =  0.5 * (dps_ac / H_ac);
                Fj2          =  Fj * Fj;
                QG           =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                temp         =  alpha_ac * dps_ac * `oneSixth;
                if (SWQPART == 1) begin
                    QCLM         =  0.0;
                    QD           =  0.5 * GdL_ac * GdL_ac * (qim_ac - 3.0 * temp * (2.0 - Fj));
                end else begin
                    QCLM         =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                    QD           =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                end
                QI           =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                QB           =  QG - QI;
            end
            Qg           =  QG * COX_qm;
            Qd           = -QD * COX_qm;
            Qb           = -QB * COX_qm;

            //  Inner fringe charge model
            Qsinr        =  0.0;
            Qdinr        =  0.0;
            Qginr        =  0.0;
            if ((CINR_i > 0.0)||(CINRD_i > 0.0)) begin
                finracc      =  1.0;
                dVinracc     =  0.0;
                if (FCINRACC_i > 1.0e-10) begin
                    Vginr        =  Vgb1_ac - DVFBINR_i + Vinr_max;
                    temp         = `MAXA(Vginr, Vinr_max, ainr);
                    temp1        =  temp * (2.0 * temp - Vinr_max - Vginr);
                    temp2        =  Vinr_max / temp;
                    Vginreff     =  Vginr * temp2;
                    fqinr        =  sqrt(1.0 - Vginreff * FCINRACC_i);
                    dVinracc     =  (1.0 - fqinr) / FCINRACC_i + Vginr - Vginreff;
                    finracc      =  (0.5 / fqinr - 1.0) * (temp1 + Vginr * (Vinr_max - temp)) * temp2 / temp1 + 1.0;
                end
                finrdep      =  1.0;
                dVinrdep     =  0.0;
                if (FCINRDEP_i > 0.0) begin
                    temp         =  0.5 * phib_ac + phit1 * (1.0 + Gf_ac * `invSqrt2);
                    xginrdep     =  Vgb1_ac / temp;
                    if (abs(xginrdep) < `se05) begin
                        finrdep      =  1.0 / (1.0 + exp(-xginrdep));
                    end else begin
                        if (xginrdep < 0.0) begin
                            finrdep      =  `ke05 / `P3(-`se05 + xginrdep);
                        end
                    end
                    if (xginrdep < `se05) begin
                        temp1        =  ln(1.0 + exp(xginrdep));
                    end else begin
                        temp1        =  xginrdep;
                    end
                    dVinrdep     =  temp * temp1;
                end
                finr         =  FCINRDEP_i * (finrdep - finracc) + finracc;
                dVinr        =  FCINRDEP_i * (dVinrdep - dVinracc) + dVinracc;
                if (sigVds > 0.0) begin
                    Qginr        =  finr * (CINRD_i * Vgdinr_ac + CINR_i * Vgsinr_ac);
                    Qsinr        =  CINR_i * (Vsginr_ac - dVinr);
                    Qdinr        =  CINRD_i * (Vdginr_ac - dVinr);
                end else begin
                    Qginr        =  finr * (CINR_i * Vgdinr_ac + CINRD_i * Vgsinr_ac);
                    Qsinr        =  CINRD_i * (Vsginr_ac - dVinr);
                    Qdinr        =  CINR_i * (Vdginr_ac - dVinr);
                end
                Qg           =  Qg + Qginr;
                Qd           =  Qd + Qdinr;
                Qb           =  Qb - Qginr - Qdinr - Qsinr;
            end

            //  Overlaps charge model
            Qgs_ov       =  CGOV_i * Vovs;
            Qgd_ov       =  CGOVD_i * Vovd;
            Qg_ov_s      =  0.0;
            yb_ov_s      =  0.0;
            if ((CGOV_i > 0.0)&&(FCGOVACC_i > 0.0)) begin
                temp         =  CGOVACCG_i * (0.5 * xgb_ov + dxgb_ov_s);
                if (temp < `se05) begin
                    `expl_low(temp, yb_ov_s)
                    if (yb_ov_s > 1.0e-10) begin
                        xgbeff_ov_s  =  ln(1.0 + yb_ov_s);
                        temp1        =  xgbeff_ov_s * (1.0 - ln(1.0 + xgbeff_ov_s) / (2.0 + xgbeff_ov_s));
                    end else begin
                        xgbeff_ov_s  =  yb_ov_s;
                        temp1        =  2.0 * xgbeff_ov_s / (2.0 + xgbeff_ov_s);
                    end
                end else begin
                    xgbeff_ov_s  =  temp;
                    temp1        =  xgbeff_ov_s * (1.0 - ln(1.0 + xgbeff_ov_s) / (2.0 + xgbeff_ov_s));
                end
                Qg_ov_s      = -2.0 * FCGOVACC_i / CGOVACCG_i * CGOV_i * phita * temp1;
            end
            Qg_ov_d      =  0.0;
            yb_ov_d      =  0.0;
            if ((CGOVD_i > 0.0)&&(FCGOVACCD_i > 0.0)) begin
                temp         =  CGOVACCG_i * (0.5 * xgb_ov + dxgb_ov_d);
                if (temp < `se05) begin
                    `expl_low(temp, yb_ov_d)
                    if (yb_ov_s > 1.0e-10) begin
                        xgbeff_ov_d  =  ln(1.0 + yb_ov_d);
                        temp1        =  xgbeff_ov_d * (1.0 - ln(1.0 + xgbeff_ov_d) / (2.0 + xgbeff_ov_d));
                    end else begin
                        xgbeff_ov_d  =  yb_ov_d;
                        temp1        =  2.0 * xgbeff_ov_d / (2.0 + xgbeff_ov_d);
                    end
                end else begin
                    xgbeff_ov_d  =  temp;
                    temp1        =  xgbeff_ov_d * (1.0 - ln(1.0 + xgbeff_ov_d) / (2.0 + xgbeff_ov_d));
                end
                Qg_ov_d      = -2.0 * FCGOVACCD_i / CGOVACCG_i * CGOVD_i * phita * temp1;
            end
            Qg_ov        =  Qg_ov_s + Qg_ov_d;
            Qgb_ov       =  CGBOV_i * Vgb + Qg_ov;

            //  Outer fringe charges
            Qfgs         =  CFR_i * VgsPrime;
            Qfgd         =  CFRD_i * VgdPrime;

            //  Variables for NQS model
            `ifdef NQSmodel
                Gp           =  0.0;
                Gp2          =  0.0;
                a_factrp     =  0.0;
                marginp      =  0.0;
                if (SWNQS_i != 0) begin
                    if (xg_ac <= 0.0) begin
                        ym           =  0.5;
                        pd           =  1.0;
                        Gp           =  Gf_ac;
                    end else begin
                        ym           =  0.5 * ( 1.0 + 0.25 * (dps_ac / H_ac));
                        pd           =  xgm_ac / (xg_ac - x_m_ac);
                        Gp           =  Gf_ac / pd;
                    end
                    Gp2          =  Gp * Gp;
                    a_factrp     =  1.0 + Gp * `invSqrt2;
                    marginp      =  1.0e-5 * a_factrp;
                end
            `endif // NQSmodel

        end // evaluateDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  JUNCAP2 contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStaticDynamic

            //  Fix: add here variables declaration; required for some verilog-A compilers
            `LocalGlobalVars

            // Fix: initialization of (local) variables; required for some verilog-A compilers
            `JuncapLocalVarInit

            ijun_s       =  0.0;
            ijunbot_s    =  0.0;
            ijunsti_s    =  0.0;
            ijungat_s    =  0.0;
            ijun_d       =  0.0;
            ijunbot_d    =  0.0;
            ijunsti_d    =  0.0;
            ijungat_d    =  0.0;
            qjun_s       =  0.0;
            qjunbot_s    =  0.0;
            qjunsti_s    =  0.0;
            qjungat_s    =  0.0;
            qjun_d       =  0.0;
            qjunbot_d    =  0.0;
            qjunsti_d    =  0.0;
            qjungat_d    =  0.0;
            if (SWJUNCAP > 0) begin
                if (SWJUNEXP_i == 1) begin
                    `JuncapExpressCurrent(Vjun_s, MFOR1_s, ISATFOR1_s, MFOR2_s, ISATFOR2_s, MREV_s, ISATREV_s, m0flag_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s, ijun_s)
                    `JuncapExpressCurrent(Vjun_d, MFOR1_d, ISATFOR1_d, MFOR2_d, ISATFOR2_d, MREV_d, ISATREV_d, m0flag_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d, ijun_d)
                    begin : evaluateDynamic
                        real tmpv, vjv;
                        `JuncapExpressCharge(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot,   qprefsti,   qprefgat,   qpref2bot,   qpref2sti,   qpref2gat,   vbiinvbot,   vbiinvsti,   vbiinvgat,   one_minus_PBOT,   one_minus_PSTI,   one_minus_PGAT,   vfmin_s, vch_s, zflagbot_s, zflagsti_s, zflaggat_s, qjunbot_s, qjunsti_s, qjungat_s)
                        `JuncapExpressCharge(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qprefsti_d, qprefgat_d, qpref2bot_d, qpref2sti_d, qpref2gat_d, vbiinvbot_d, vbiinvsti_d, vbiinvgat_d, one_minus_PBOT_d, one_minus_PSTI_d, one_minus_PGAT_d, vfmin_d, vch_d, zflagbot_d, zflagsti_d, zflaggat_d, qjunbot_d, qjunsti_d, qjungat_d)
                    end
                end else begin
                    `juncapcommon(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s, ijunbot_s, qjunbot_s, ijunsti_s, qjunsti_s, ijungat_s, qjungat_s)
                    ijun_s = ABSOURCE_i * ijunbot_s + LSSOURCE_i * ijunsti_s + LGSOURCE_i * ijungat_s;
                    `juncapcommon(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d, ijunbot_d, qjunbot_d, ijunsti_d, qjunsti_d, ijungat_d, qjungat_d)
                    ijun_d = ABDRAIN_i * ijunbot_d + LSDRAIN_i * ijunsti_d + LGDRAIN_i * ijungat_d;
                end
            end

            //  --------------------------------------------------------------------------------------------------------------
            //  NQS and parasitic resistance contribs
            //  --------------------------------------------------------------------------------------------------------------

            //  Set initial conditions for NQS model
            `ifdef NQSmodel
                `InitNQS
            `endif // NQSmodel

            //  Parasitic resistances (including noise)
            rgatenoise   =  nt0 * ggate;
            rsourcenoise =  nt0 * gsource;
            rdrainnoise  =  nt0 * gdrain;
            rbulknoise   =  nt0 * gbulk;
            rjunsnoise   =  nt0 * gjuns;
            rjundnoise   =  nt0 * gjund;
            rwellnoise   =  nt0 * gwell;

        end // evaluateStaticDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Current contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStatic

            //  Convert back for NMOS-PMOS and Source-Drain interchange
            if (sigVds > 0.0) begin
                I(DI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(DI, SI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcd;
            end else begin
                I(SI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(SI, DI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcd;
            end
            I(GP, BP)    <+  CHNL_TYPE * MULT_i * Igb;
            I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igsov;
            I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igdov;
            I(SI, BP)    <+  CHNL_TYPE * MULT_i * Igisl;
            I(DI, BP)    <+  CHNL_TYPE * MULT_i * Igidl;
            I(BS, SI)    <+  CHNL_TYPE * MULT_i * ijun_s;
            I(BD, DI)    <+  CHNL_TYPE * MULT_i * ijun_d;

            `CollapsableR(ggate,   RG_i,    rgatenoise,   G,  GP, "rgate")
            `CollapsableR(gsource, RSE_i,   rsourcenoise, S,  SI, "rsource")
            `CollapsableR(gdrain,  RDE_i,   rdrainnoise,  D,  DI, "rdrain")
            `CollapsableR(gbulk,   RBULK_i, rbulknoise,   BP, BI, "rbulk")
            `CollapsableR(gjuns,   RJUNS_i, rjunsnoise,   BS, BI, "rjuns")
            `CollapsableR(gjund,   RJUND_i, rjundnoise,   BD, BI, "rjund")
            `CollapsableR(gwell,   RWELL_i, rwellnoise,   B,  BI, "rwell")

            I(DI, BP)    <+  gmin * V(DI, BP);
            I(SI, BP)    <+  gmin * V(SI, BP);

        end // loadStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  ddt() contribs from charges (Note: MULT is handled explicitly)
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStaticDynamic

            //  Implementation of NQS charges
            `ifdef NQSmodel
                `CalcChargesNQS
            `endif // NQSmodel

            //  Implementation of Self heating effect
            `ifdef SelfHeating
                begin : self_heating
                    real Pdiss_s, Pdiss_d;
                    Pdiss        =  0.0;
                    Pdiss_s      =  0.0;
                    Pdiss_d      =  0.0;
                    if (RSE_i > 0.0) begin
                        Pdiss_s      =  gsource * V(S, SI) * V(S, SI);
                    end
                    if (RDE_i > 0.0) begin
                        Pdiss_d      =  gdrain * V(D, DI) * V(D, DI);
                    end
                    if (RTH_p > 1.0e-3) begin
                        Pdiss        =  ((Ids + Idsedge) * Vds + Iimpact * (Vds + Vsb) + Pdiss_s + Pdiss_d);
                    end
                    Pwr(br_ith)  <+ -MULT_i * Pdiss;
                    Pwr(br_rth)  <+  ddt(MULT_i * CTH_i * Temp(br_rth));
                    Pwr(br_rth)  <+  MULT_i * Temp(br_rth) / RTH_T;
                end // self_heating
            `endif // SelfHeating

        end // loadStaticDynamic

        begin : loadDynamic

            //  Local variable
            real temp;

            //  Intrinsic MOSFET charges
            Qs           =  -(Qg + Qb + Qd);

            //  Total outerFringe + overlap for gate-source and gate-drain.
            Qfgs         =  Qfgs + Qgs_ov;
            Qfgd         =  Qfgd + Qgd_ov;

            //  JUNCAP2 charges
            qjun_s       =  ABSOURCE_i * qjunbot_s + LSSOURCE_i * qjunsti_s + LGSOURCE_i * qjungat_s;
            qjun_d       =  ABDRAIN_i * qjunbot_d + LSDRAIN_i * qjunsti_d + LGDRAIN_i * qjungat_d;

            //  Convert back (undo S-D interchange)
            if (sigVds < 0.0) begin
                temp         =  Qd;    // Qd <--> Qs
                Qd           =  Qs;
                Qs           =  temp;
            end

            I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qg);
            I(BP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qb);
            I(DI, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qd);
            I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgs);
            I(GP, DI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgd);
            I(GP, BP)    <+  ddt(CHNL_TYPE * MULT_i * Qgb_ov);
            I(BS, SI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_s);
            I(BD, DI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_d);

        end // loadDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Noise
        //  --------------------------------------------------------------------------------------------------------------
        begin : noise

            //  Noise variable calculation
            Sfl          =  0.0;
            Sidexc       =  0.0;
            mid          =  0.0;
            mig          =  1.0e-40;
            migid        =  0.0;
            c_igid       =  0.0;
            CGeff        =  COX_qm * eta_p_ac;
            sqid         =  0.0;
            sqig         =  0.0;
            Sfledge      =  0.0;
            midedge      =  0.0;
            sqidedge     =  0.0;

            //  Channel noise contributions
            if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin
                // Flicker noise
                N1           =  Cox_over_q * alpha_dc * phit;
                Nm1          =  Cox_over_q * qim1_dc;
                Delta_N1     =  Cox_over_q * alpha_dc * dps_dc;
                Sfl          =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                Sfl          =  Sfl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                Sfl          =  Sfl_prefac * Ids * Gvsatinv_dc * Sfl / N1;
                Sfl          = `CLIP_LOW(Sfl, 0.0);

                //  Thermal channel noise
                H0           =  qim1_dc / alpha_dc;
                t1           =  qim_dc / qim1_dc;
                sqt2         =  0.5 * `oneSixth * (dps_dc / H0);
                t2           =  sqt2 * sqt2;
                r            =  H0 / H_dc - 1.0;
                lc           = `CLIP_LOW(1.0 - 12.0 * (r * t2), 1.0e-20);
                lcinv2       =  1.0 / (lc * lc);
                g_ideal      =  BET_i * (FdL_dc * qim1_dc * Gvsatinv_dc);
                mid          =  t1 + 12.0 * t2 - 24.0 * ((1.0 + t1) * t2 * r);
                mid          = `CLIP_LOW(mid, 1.0e-40);
                mid          =  g_ideal * lcinv2 * mid;
                if (FNTEXC_i > 0.0) begin
                    //  Recalculate Gvsat, excluding Gmob-effect
                    temp2_exc    =  qim_dc * xitsb_dc;
                    wsat_exc     =  100.0 * (temp2_exc / (100.0 + temp2_exc));
                    if (THESATG_i < 0) begin
                        temp_exc     = 1.0 / (1.0 - THESATG_i * wsat_exc);
                    end else begin
                        temp_exc     = 1.0 + THESATG_i * wsat_exc;
                    end
                    thesat1_exc  =  THESAT_T * (temp_exc / Gmob_dc);
                    zsat_exc     =  thesat1_exc * thesat1_exc * dps_dc * dps_dc;
                    if (CHNL_TYPE == `PMOS) begin
                        zsat_exc     =  zsat_exc / (1.0 + thesat1_exc * dps_dc);
                    end
                    Gvsat_exc    =  0.5 * (Gmob_dc * (1.0 + sqrt(1.0 + 2.0 * zsat_exc)));
                    gfac         =  Gmob_dc / (Gvsat_exc * lc);
                    Sidexc       =  fac_exc * Ids * Vdse_dc * gfac * gfac;
                    mid          =  mid + Sidexc / nt0;
                end
                sqid         =  sqrt(nt * mid);

                //  Induced gate noise
                if ((SWIGN == 1) && (nt > 0.0)) begin
                    mig          =  t1 / 12.0 - t2 * (t1 + 0.2 - 12.0 * t2) - 1.6 * (t2 * (t1 + 1.0 - 12.0 * t2) * r);
                    mig          = `CLIP_LOW(mig, 1.0e-40);
                    mig          =  lcinv2 / g_ideal * mig;
                    migid0       =  lcinv2 * sqt2 * (1.0 - 12.0 * t2 - (t1 + 19.2 * t2 - 12.0 * (t1 * t2)) * r);
                    CGeff        =  Gvsat_ac * Gvsat_ac * COX_qm * eta_p_ac / (Gmob_dL_ac * Gmob_dL_ac);
                    if (FNTEXC_i > 0.0) begin
                        mig          =  mig + Sidexc * (1.0 + 12.0 * t2) / (12.0 * g_ideal * g_ideal * nt0);
                        migid0       =  migid0 - Sidexc * sqt2 * (1.0 + r) / (g_ideal * nt0);
                    end
                    sqig         =  sqrt(nt / mig);
                    if (sqid == 0) begin
                        c_igid       =  0.0;
                    end else begin
                        c_igid       =  migid0 * sqig / sqid; // = migid0 / sqrt(mig * mid);
                    end
                    c_igid       = `CLIP_BOTH(c_igid, 0.0, 1.0);
                    migid        =  c_igid * sqid / sqig;
                end
            end

            //  Noise of gate leakage currents
            shot_igcsx   =  2.0 * `QELE * abs(Igcs);
            shot_igcdx   =  2.0 * `QELE * abs(Igcd);
            shot_igsov   =  2.0 * `QELE * abs(Igsov);
            shot_igdov   =  2.0 * `QELE * abs(Igdov);

            //  Noise of impact ionization currents
            shot_iavl    =  2.0 * `QELE * ((mavl + 1) * abs(Iimpact));

            //  Noise of junctions (JUNCAP2)
            jnoisex_s    =  2.0 * `QELE * abs(ijun_s);
            jnoisex_d    =  2.0 * `QELE * abs(ijun_d);
            if (sigVds > 0.0) begin
                shot_igs     =  shot_igcsx + shot_igsov;
                shot_igd     =  shot_igcdx + shot_igdov;
                jnoise_s     =  jnoisex_s;
                jnoise_d     =  jnoisex_d + shot_iavl;
            end else begin
                shot_igs     =  shot_igcdx + shot_igsov;
                shot_igd     =  shot_igcsx + shot_igdov;
                jnoise_s     =  jnoisex_s + shot_iavl;
                jnoise_d     =  jnoisex_d;
            end

            //  Noise of edge transistors
            if ((SWEDGE != 0) && (BETNEDGE_i > 0.0) && (xgedge > 0.0)) begin
                // Flicker noise of edge transistor
                temp1        =  4.0 * dsqredge / Gfedge2;
                anoisedge    =  sqrt(temp1 + 1.0) / (sqrt(temp1 + 1.1) - 1.0);
                temp1        =  Cox_over_q * phit;
                N1edge       =  temp1 * anoisedge;
                Nm1edge      =  temp1 * (qmeffedge + anoisedge);
                Delta_N1edge = -temp1 * anoisedge * alphabmedge * qdseffedge;
                Sfledge      =  (NFAEDGE_i - (NFBEDGE_i - NFCEDGE_i * N1edge) * N1edge) * ln((Nm1edge + 0.5 * Delta_N1edge) / (Nm1edge - 0.5 * Delta_N1edge));
                Sfledge      =  Sfledge + (NFBEDGE_i + NFCEDGE_i * (Nm1edge - 2.0 * N1edge)) * Delta_N1edge;
                Sfledge      =  Sfl_prefac_edge * Idsedge * Gvsatinv_dc * Sfledge / N1edge;
                Sfledge      = `CLIP_LOW(Sfledge, 0.0);

                //  Thermal channel noise of edge transistor
                H0edge       =  phit * (qmeffedge + anoisedge) / anoisedge;
                t1edge       =  phit1 / phit * qmeffedge / (qmeffedge + anoisedge);
                sqt2edge     = -0.5 * `oneSixth * phit * alphabmedge * qdseffedge / H0edge;
                t2edge       =  sqt2edge * sqt2edge;
                redge        =  0.0;
                temp1        =  alpha_dc * H_dc;
                if (temp1 > 1.0e-10) begin
                    redge        =  anoisedge * H0edge / temp1 - 1.0;
                end
                lcedge       = `CLIP_LOW(1.0 - 12.0 * (redge * t2edge), 1.0e-20);
                lcinv2edge   =  1.0 / (lcedge * lcedge);
                g_idealedge  =  BETEDGE_i * phit * (qmeffedge + anoisedge) * FdL_dc * Gvsatinv_dc;
                midedge      =  t1edge + 12.0 * t2edge - 24.0 * ((1.0 + t1edge) * t2edge * redge);
                midedge      = `CLIP_LOW(midedge, 1.0e-40);
                midedge      =  g_idealedge * lcinv2edge * midedge;
                sqidedge     =  sqrt(ntedge * midedge);
            end

            //  Noise contributions
            I(NOII)      <+  white_noise((nt / mig), "igig");
            I(NOIR)      <+  V(NOIR) / mig;
            I(NOIC)      <+  ddt(CGeff * V(NOIC));
            I(GP,SI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
            I(GP,DI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
            I(DI,SI)     <+  sigVds * sqrt(MULT_i) * migid * I(NOII);
            I(DI,SI)     <+  white_noise(MULT_i * sqid * sqid * (1.0 - c_igid * c_igid), "idid");
            I(DI,SI)     <+  flicker_noise(sigVds * MULT_i * Sfl, EF_i, "flicker");
            I(GP,SI)     <+  white_noise(MULT_i * shot_igs, "igs");
            I(GP,DI)     <+  white_noise(MULT_i * shot_igd, "igd");
            I(BS,SI)     <+  white_noise(MULT_i * jnoise_s, "ibs");
            I(BD,DI)     <+  white_noise(MULT_i * jnoise_d, "ibd");
            I(DI,SI)     <+  flicker_noise(sigVds * MULT_i * Sfledge, EFEDGE_i, "flicker");
            I(DI,SI)     <+  white_noise(MULT_i * sqidedge * sqidedge, "ididedge");

        end // noise

        //  --------------------------------------------------------------------------------------------------------------
        //  Operating point info
        //  --------------------------------------------------------------------------------------------------------------
        begin : OPinfo

            //  Auxiliary variables
            id_op        =  Ids + Idsedge + Iimpact - Igcd;
            is           = -Ids - Idsedge - Igcs;
            ig           =  Igcs + Igcd + Igsov + Igdov + Igb;
            ib           = -Iimpact - Igb - Igidl - Igisl;
            sig1k        =  2.0e3 * `PI * CGeff;
            sig1k        =  sig1k * sig1k * mig;

            //  Actual operation point output variables
            sdint        =  sigVds;
            ctype        =  CHNL_TYPE;
            if (sigVds < 0.0) begin
                ise          =  MULT_i * (is - Igdov + Igidl - ijun_d);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igsov + Igisl - ijun_s);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igisl - ijun_s);
                isb          =  MULT_i * (Igidl - ijun_d);
                igs          =  MULT_i * (Igcs + Igdov);
                igd          =  MULT_i * (Igcd + Igsov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igidl;
                igidl        =  MULT_i * Igisl;
                if (SWJUNEXP_i == 1) begin
                    ijsbot       =  0.0;
                    ijsgat       =  0.0;
                    ijssti       =  0.0;
                    ijdbot       =  0.0;
                    ijdgat       =  0.0;
                    ijdsti       =  0.0;
                    idsatsbot    =  0.0;
                    idsatssti    =  0.0;
                    idsatsgat    =  0.0;
                    idsatsbotd   =  0.0;
                    idsatsstid   =  0.0;
                    idsatsgatd   =  0.0;
                end else begin
                    ijsbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                    ijsgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                    ijssti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                    ijdbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                    ijdgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                    ijdsti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                    idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                    idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                    idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                    idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                    idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                    idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                end
                ijs          =  MULT_i * ijun_d;
                ijd          =  MULT_i * ijun_s;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igisl - Igcd - Igsov - ijun_s; // Total drain-current
                `ifdef OPderiv
                    gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                    gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                    gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(SI));
                    gjs          =  MULT_i * ddx(ijun_d, V(BD));
                    gjd          =  MULT_i * ddx(ijun_s, V(BS));
                    css          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                    csg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                    csb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                    csd          =  css - csg - csb;
                    cgs          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                    cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                    cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                    cgd          =  cgg - cgs - cgb;
                    cds          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                    cdg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                    cdb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                    cdd          =  cdg + cds + cdb;
                    cbs          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                    cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                    cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                    cbd          =  cbb - cbs - cbg;
                    cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                    cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                    cjsbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                    cjsgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                    cjssti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                    cjs          =  cjsbot + cjsgat + cjssti;
                    cjdbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                    cjdgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                    cjdsti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                    cjd          =  cjdbot + cjdgat + cjdsti;
                `endif // OPderiv
            end else begin
                ise          =  MULT_i * (is - Igsov + Igisl - ijun_s);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igdov + Igidl - ijun_d);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igidl - ijun_d);
                isb          =  MULT_i * (Igisl - ijun_s);
                igs          =  MULT_i * (Igcs + Igsov);
                igd          =  MULT_i * (Igcd + Igdov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igisl;
                igidl        =  MULT_i * Igidl;
                if (SWJUNEXP_i == 1) begin
                    ijsbot       =  0.0;
                    ijsgat       =  0.0;
                    ijssti       =  0.0;
                    ijdbot       =  0.0;
                    ijdgat       =  0.0;
                    ijdsti       =  0.0;
                    idsatsbot    =  0.0;
                    idsatssti    =  0.0;
                    idsatsgat    =  0.0;
                    idsatsbotd   =  0.0;
                    idsatsstid   =  0.0;
                    idsatsgatd   =  0.0;
                end else begin
                    ijsbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                    ijsgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                    ijssti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                    ijdbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                    ijdgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                    ijdsti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                    idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                    idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                    idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                    idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                    idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                    idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                end
                ijs          =  MULT_i * ijun_s;
                ijd          =  MULT_i * ijun_d;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igidl - Igcd - Igdov - ijun_d; // Total drain-current
                `ifdef OPderiv
                    gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                    gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                    gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(DI));
                    gjs          = -MULT_i * ddx(ijun_s, V(SI));
                    gjd          = -MULT_i * ddx(ijun_d, V(DI));
                    cdd          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                    cdg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                    cdb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                    cds          =  cdd - cdg - cdb;
                    cgd          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                    cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                    cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                    cgs          =  cgg - cgd - cgb;
                    csd          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                    csg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                    csb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                    css          =  csg + csd + csb;
                    cbd          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                    cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                    cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                    cbs          =  cbb - cbd - cbg;
                    cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                    cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                    cjsbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                    cjsgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                    cjssti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                    cjs          =  cjsbot + cjsgat + cjssti;
                    cjdbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                    cjdgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                    cjdsti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                    cjd          =  cjdbot + cjdgat + cjdsti;
                `endif // OPderiv
            end
            weff         =  WE;
            leff         =  LE;
            `ifdef OPderiv
                if (abs(gds) < 1.0e-18) begin
                    u            =  0.0;
                    rout         =  0.0;
                    vearly       =  0.0;
                end else begin
                    u            =  gm / gds;
                    rout         =  1.0 / gds;
                    vearly       =  ide / gds;
                end
                if (abs(vgt) < 1.0e-12) begin
                    beff         =  0.0;
                end else begin
                    beff         =  2.0 * abs(ide) / (vgt * vgt);
                end
                if (abs(cgg + cgsol + cgdol) < 1.0e-30) begin
                    fug          =  0.0;
                end else begin
                    fug          =  gm / (2.0 * `PI * (cgg + cgsol + cgdol));
                end
                rg           =  RG_i / MULT_i;
                sfl          =  MULT_i * Sfl;
                if (abs(gm) < 1.0e-18) begin
                    sqrtsff      =  0.0;
                    sqrtsfw      =  0.0;
                end else begin
                    sqrtsff      =  sqrt(MULT_i * Sfl / 1000.0) / gm;
                    sqrtsfw      =  sqrt(MULT_i) * sqid / gm;
                end
                sid          =  MULT_i * sqid * sqid;
                sig          =  MULT_i * nt * sig1k / (1.0 + sig1k * mig);
                cigid        =  c_igid;
                if (sid == 0.0) begin
                    fknee        =  0.0;
                end else begin
                    fknee        =  sfl / sid;
                end
                siavl        =  MULT_i * shot_iavl;
                if (sigVds < 0.0) begin
                    sigs         =  MULT_i * (shot_igcsx + shot_igdov);
                    sigd         =  MULT_i * (shot_igcdx + shot_igsov);
                    ssi          =  MULT_i * jnoisex_d;
                    sdi          =  MULT_i * jnoisex_s;
                end else begin
                    sigs         =  MULT_i * (shot_igcsx + shot_igsov);
                    sigd         =  MULT_i * (shot_igcdx + shot_igdov);
                    ssi          =  MULT_i * jnoisex_s;
                    sdi          =  MULT_i * jnoisex_d;
                end
                sfledge      =  MULT_i * Sfledge;
                sidedge      =  MULT_i * sqidedge;
            `endif // OPderiv

            lp_vfb       =  VFB_T;
            lp_stvfb     =  STVFB_i;
            lp_st2vfb    =  ST2VFB_i;
            lp_tox       =  TOX_i;
            lp_epsrox    =  EPSROX_i;
            lp_neff      =  NEFF_i;
            lp_facneffac =  FACNEFFAC_i;
            lp_gfacnud   =  GFACNUD_i;
            lp_vsbnud    =  VSBNUD_i;
            lp_dvsbnud   =  DVSBNUD_i;
            lp_vnsub     =  VNSUB_i;
            lp_nslp      =  NSLP_i;
            lp_dnsub     =  DNSUB_i;
            lp_dphib     =  DPHIB_i;
            lp_delvtac   =  DELVTAC_i;
            lp_np        =  NP_i;
            lp_toxov     =  TOXOV_i;
            lp_toxovd    =  TOXOVD_i;
            lp_nov       =  NOV_i;
            lp_novd      =  NOVD_i;
            lp_ct        =  CT_T;
            lp_ctg       =  CTG_T;
            lp_ctb       =  CTB_i;
            lp_stct      =  STCT_i;
            lp_cf        =  CF_i;
            lp_cfac      =  CFAC_i;
            lp_cfd       =  CFD_i;
            lp_cfb       =  CFB_i;
            lp_psce      =  PSCE_i;
            lp_psceb     =  PSCEB_i;
            lp_psced     =  PSCED_i;
            lp_betn      =  BETN_T;
            lp_stbet     =  STBET_i;
            lp_mue       =  MUE_T;
            lp_stmue     =  STMUE_i;
            lp_themu     =  THEMU_T;
            lp_stthemu   =  STTHEMU_i;
            lp_cs        =  CS_T;
            lp_stcs      =  STCS_i;
            lp_thecs     =  THECS_T;
            lp_stthecs   =  STTHECS_i;
            lp_xcor      =  XCOR_T;
            lp_stxcor    =  STXCOR_i;
            lp_feta      =  FETA_i;
            lp_rs        =  RS_T;
            lp_strs      =  STRS_i;
            lp_rsb       =  RSB_i;
            lp_rsg       =  RSG_i;
            lp_thesat    =  THESAT_T;
            lp_thesatac  =  THESATAC_T;
            lp_stthesat  =  STTHESAT_i;
            lp_thesatb   =  THESATB_i;
            lp_thesatg   =  THESATG_i;
            lp_ax        =  AX_i;
            lp_axac      =  AXAC_i;
            lp_alp       =  ALP_i;
            lp_alpac     =  ALPAC_i;
            lp_alp1      =  ALP1_i;
            lp_alp2      =  ALP2_i;
            lp_vp        =  VP_i;
            lp_a1        =  A1_i;
            lp_a2        =  A2_T;
            lp_sta2      =  STA2_i;
            lp_a3        =  A3_i;
            lp_a4        =  A4_i;
            lp_gco       =  GCO_i;
            lp_iginv     =  IGINV_i;
            lp_igov      =  IGOV_i;
            lp_igovd     =  IGOVD_i;
            lp_stig      =  STIG_i;
            lp_gc2       =  GC2_i;
            lp_gc3       =  GC3_i;
            lp_gc2ov     =  GC2OV_i;
            lp_gc3ov     =  GC3OV_i;
            lp_chib      =  CHIB_i;
            lp_agidl     =  AGIDL_i;
            lp_agidld    =  AGIDLD_i;
            lp_bgidl     =  BGIDL_T;
            lp_bgidld    =  BGIDLD_T;
            lp_stbgidl   =  STBGIDL_i;
            lp_stbgidld  =  STBGIDLD_i;
            lp_cgidl     =  CGIDL_i;
            lp_cgidld    =  CGIDLD_i;
            lp_cox       =  COX_i;
            lp_cgov      =  CGOV_i;
            lp_cgovd     =  CGOVD_i;
            lp_fcgovacc  =  FCGOVACC_i;
            lp_fcgovaccd =  FCGOVACCD_i;
            lp_cgovaccg  =  CGOVACCG_i;
            lp_cgbov     =  CGBOV_i;
            lp_cinr      =  CINR_i;
            lp_cinrd     =  CINRD_i;
            lp_dvfbinr   =  DVFBINR_i;
            lp_fcinrdep  =  FCINRDEP_i;
            lp_fcinracc  =  FCINRACC_i;
            lp_axinr     =  AXINR_i;
            lp_cfr       =  CFR_i;
            lp_cfrd      =  CFRD_i;
            lp_fnt       =  FNT_i;
            lp_fntexc    =  FNTEXC_i;
            lp_nfa       =  NFA_i;
            lp_nfb       =  NFB_i;
            lp_nfc       =  NFC_i;
            lp_ef        =  EF_i;
            lp_vfbedge   =  VFBEDGE_T;
            lp_stvfbedge =  STVFBEDGE_i;
            lp_dphibedge =  DPHIBEDGE_i;
            lp_neffedge  =  NEFFEDGE_i;
            lp_ctedge    =  CTEDGE_i;
            lp_betnedge  =  BETNEDGE_T;
            lp_stbetedge =  STBETEDGE_i;
            lp_psceedge  =  PSCEEDGE_i;
            lp_pscebedge =  PSCEBEDGE_i;
            lp_pscededge =  PSCEDEDGE_i;
            lp_cfedge    =  CFEDGE_i;
            lp_cfdedge   =  CFDEDGE_i;
            lp_cfbedge   =  CFBEDGE_i;
            lp_fntedge   =  FNTEDGE_i;
            lp_nfaedge   =  NFAEDGE_i;
            lp_nfbedge   =  NFBEDGE_i;
            lp_nfcedge   =  NFCEDGE_i;
            lp_efedge    =  EFEDGE_i;
            lp_rg        =  RG_i;
            lp_rse       =  RSE_i;
            lp_rde       =  RDE_i;
            lp_rbulk     =  RBULK_i;
            lp_rwell     =  RWELL_i;
            lp_rjuns     =  RJUNS_i;
            lp_rjund     =  RJUND_i;
            `ifdef SelfHeating
                lp_rth       =  RTH_i;
                lp_cth       =  CTH_i;
                lp_strth     =  STRTH_i;
                pdiss        =  MULT_i * Pdiss;
                dtsh         =  TKD - TKA;
            `endif // SelfHeating
            tk           =  TKD;
            cjosbot      =  MULT_i * ABSOURCE_i * cjobot;
            cjossti      =  MULT_i * LSSOURCE_i * cjosti;
            cjosgat      =  MULT_i * LGSOURCE_i * cjogat;
            vbisbot      =  vbibot;
            vbissti      =  vbisti;
            vbisgat      =  vbigat;
            cjosbotd     =  MULT_i * ABDRAIN_i * cjobot_d;
            cjosstid     =  MULT_i * LSDRAIN_i * cjosti_d;
            cjosgatd     =  MULT_i * LGDRAIN_i * cjogat_d;
            vbisbotd     =  vbibot_d;
            vbisstid     =  vbisti_d;
            vbisgatd     =  vbigat_d;
            `ifdef NQSmodel
                lp_munqs     =  MUNQS_i;
            `endif // NQSmodel

        end // OPinfo

    end // evaluateblock

end // analogBlock
